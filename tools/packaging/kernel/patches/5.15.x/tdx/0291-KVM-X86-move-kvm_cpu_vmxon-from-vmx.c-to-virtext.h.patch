From 705226c62348c15b985f794a75710e03a04f950b Mon Sep 17 00:00:00 2001
From: Isaku Yamahata <isaku.yamahata@intel.com>
Date: Fri, 30 Apr 2021 11:52:02 -0700
Subject: [PATCH 0291/1418] KVM: X86: move kvm_cpu_vmxon() from vmx.c to
 virtext.h

To enable TDX, the TDX firmware must first be loaded during kernel boot.
Loading TDX firmware requires all CPUs to have VMX(Virtual Machine
eXtensions) enabled, and in and in VMX operation via the VMXON instruction.

Because the kvm_cpu_vmxon() function will be used outside of KVM, move it
from vmx.c to virtext.h and rename to cpu_vmxon().  In the kernel's boot
phase, invoke the TDX firmware loader (P-SEAMLDR) to load the TDX module
firmware via a SEAMCALL instruction, which requires VMX enabled (VMXON).
As a bonus, this also matches with cpu_vmxoff().

No functional change is intended.

Signed-off-by: Isaku Yamahata <isaku.yamahata@intel.com>
---
 arch/x86/include/asm/virtext.h | 24 ++++++++++++++++++++++++
 arch/x86/kvm/vmx/vmx.c         | 22 +---------------------
 2 files changed, 25 insertions(+), 21 deletions(-)

diff --git a/arch/x86/include/asm/virtext.h b/arch/x86/include/asm/virtext.h
index 8757078d4442..8efd0147dcce 100644
--- a/arch/x86/include/asm/virtext.h
+++ b/arch/x86/include/asm/virtext.h
@@ -29,6 +29,30 @@ static inline int cpu_has_vmx(void)
 	return test_bit(5, &ecx); /* CPUID.1:ECX.VMX[bit 5] -> VT */
 }
 
+/*
+ * cpu_vmxon() - Enable VMX on the current CPU
+ *
+ * Set CR4.VMXE and enable VMX
+ */
+static inline int cpu_vmxon(u64 vmxon_pointer)
+{
+	u64 msr;
+
+	cr4_set_bits(X86_CR4_VMXE);
+
+	asm_volatile_goto("1: vmxon %[vmxon_pointer]\n\t"
+			  _ASM_EXTABLE(1b, %l[fault])
+			  : : [vmxon_pointer] "m"(vmxon_pointer)
+			  : : fault);
+	return 0;
+
+fault:
+	WARN_ONCE(1, "VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\n",
+		  rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr);
+	cr4_clear_bits(X86_CR4_VMXE);
+
+	return -EFAULT;
+}
 
 /**
  * cpu_vmxoff() - Disable VMX on the current CPU
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index 6b6d2aafaf7c..0e7723bbcead 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -2355,26 +2355,6 @@ static __init int vmx_disabled_by_bios(void)
 	       !boot_cpu_has(X86_FEATURE_VMX);
 }
 
-static int kvm_cpu_vmxon(u64 vmxon_pointer)
-{
-	u64 msr;
-
-	cr4_set_bits(X86_CR4_VMXE);
-
-	asm_volatile_goto("1: vmxon %[vmxon_pointer]\n\t"
-			  _ASM_EXTABLE(1b, %l[fault])
-			  : : [vmxon_pointer] "m"(vmxon_pointer)
-			  : : fault);
-	return 0;
-
-fault:
-	WARN_ONCE(1, "VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\n",
-		  rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr);
-	cr4_clear_bits(X86_CR4_VMXE);
-
-	return -EFAULT;
-}
-
 static int hardware_enable(void)
 {
 	int cpu = raw_smp_processor_id();
@@ -2394,7 +2374,7 @@ static int hardware_enable(void)
 
 	intel_pt_handle_vmx(1);
 
-	r = kvm_cpu_vmxon(phys_addr);
+	r = cpu_vmxon(phys_addr);
 	if (r) {
 		intel_pt_handle_vmx(0);
 		return r;
-- 
2.31.1

