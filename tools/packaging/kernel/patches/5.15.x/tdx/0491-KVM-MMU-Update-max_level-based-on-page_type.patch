From ec8e90e5869e083408056472bc58e0e769b3da08 Mon Sep 17 00:00:00 2001
From: Xiaoyao Li <xiaoyao.li@intel.com>
Date: Tue, 31 Aug 2021 15:34:47 +0800
Subject: [PATCH 0491/1418] KVM: MMU: Update max_level based on page_type

Guest gfn can be mapped as a large page only when the large page has
consistent page type.

Signed-off-by: Xiaoyao Li <xiaoyao.li@intel.com>
---
 arch/x86/kvm/mmu/mmu.c | 42 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/arch/x86/kvm/mmu/mmu.c b/arch/x86/kvm/mmu/mmu.c
index 5053a911260a..5415d02e66b8 100644
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@ -908,6 +908,47 @@ static inline bool kvm_page_type_valid(struct kvm_page_attr *attr)
 	       attr->type == KVM_PAGE_TYPE_PRIVATE;
 }
 
+/*
+ * True means the (large) page at @level contains the given @gfn has consistent
+ * page type, either private or shared.
+ *
+ * False means the (large) page at @level contains the given @gfn has both
+ * priavte and shared smaller pages. Thus have to go to query next level.
+ */
+
+static inline bool kvm_page_type_valid_on_level(gfn_t gfn,
+						struct kvm_memory_slot *slot,
+						int level)
+{
+	struct kvm_page_attr *page_attr;
+
+	if (WARN_ON_ONCE(level > PG_LEVEL_1G))
+		return false;
+
+	page_attr = page_attr_slot(gfn, slot, level);
+
+	return kvm_page_type_valid(page_attr);
+}
+
+static int max_level_of_valid_page_type(struct kvm_vcpu *vcpu, gfn_t gfn)
+{
+	struct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);
+	int level = PG_LEVEL_1G;
+
+	if (WARN_ON(!slot))
+		return PG_LEVEL_4K;
+
+	for (; level > PG_LEVEL_NONE; level--) {
+		if (kvm_page_type_valid_on_level(gfn, slot, level))
+			break;
+	}
+
+	if (WARN_ON_ONCE(level == PG_LEVEL_NONE))
+		return PG_LEVEL_4K;
+
+	return level;
+}
+
 static void try_merge_page_type(struct kvm_vcpu *vcpu, gfn_t gfn,
 				  struct kvm_memory_slot *slot, int level)
 {
@@ -3453,6 +3494,7 @@ static int __direct_map(struct kvm_vcpu *vcpu, gpa_t gpa, u32 error_code,
 					 is_private ? KVM_PAGE_TYPE_PRIVATE :
 						      KVM_PAGE_TYPE_SHARED);
 		kvm_mmu_zap_alias_spte(vcpu, gfn, gpa ^ gpa_stolen_mask);
+		max_level = min(max_level, max_level_of_valid_page_type(vcpu, gfn));
 	}
 
 	/* TDX shared GPAs are no executable, enforce this for the SDV. */
-- 
2.31.1

