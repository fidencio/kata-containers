From 0057f77c1f216924dbaaf3eb6ea8e99fa460bac4 Mon Sep 17 00:00:00 2001
From: Yuan Yao <yuan.yao@intel.com>
Date: Thu, 1 Jul 2021 16:22:31 +0800
Subject: [PATCH 0469/1418] KVM: TDX: Add basic exception injection support for
 TD guest

This function has not been testing due to SEAM module is not ready,
THD.VP.WR returns TDX_FIELD_NOT_WRITABLE when I writing the VM entry
interrupt information field (VMCS.0x4016) for debug TD now.

Signed-off-by: Yuan Yao <yuan.yao@intel.com>
---
 arch/x86/kvm/vmx/main.c      |  4 ++--
 arch/x86/kvm/vmx/tdx.c       | 37 ++++++++++++++++++++++++++++++++++++
 arch/x86/kvm/vmx/tdx_stubs.c |  1 +
 3 files changed, 40 insertions(+), 2 deletions(-)

diff --git a/arch/x86/kvm/vmx/main.c b/arch/x86/kvm/vmx/main.c
index 8f1d94f21d74..fb4cee3d329d 100644
--- a/arch/x86/kvm/vmx/main.c
+++ b/arch/x86/kvm/vmx/main.c
@@ -733,8 +733,8 @@ static void vt_inject_nmi(struct kvm_vcpu *vcpu)
 
 static void vt_queue_exception(struct kvm_vcpu *vcpu)
 {
-	if (KVM_BUG_ON(is_td_vcpu(vcpu) && !is_debug_td(vcpu), vcpu->kvm))
-		return;
+	if (is_td_vcpu(vcpu))
+		return tdx_queue_exception(vcpu);
 
 	vmx_queue_exception(vcpu);
 }
diff --git a/arch/x86/kvm/vmx/tdx.c b/arch/x86/kvm/vmx/tdx.c
index c35a57aa4e85..07bf4c4d7c40 100644
--- a/arch/x86/kvm/vmx/tdx.c
+++ b/arch/x86/kvm/vmx/tdx.c
@@ -890,6 +890,43 @@ static int tdx_handle_exception(struct kvm_vcpu *vcpu)
 	return -EFAULT;
 }
 
+static void tdx_queue_exception(struct kvm_vcpu *vcpu)
+{
+	struct vcpu_tdx *tdx;
+	unsigned int nr;
+	bool has_error_code;
+	u32 error_code;
+	u32 intr_info;
+
+	if (KVM_BUG_ON(!is_debug_td(vcpu), vcpu->kvm))
+		return;
+
+	tdx = to_tdx(vcpu);
+	nr = vcpu->arch.exception.nr;
+	has_error_code = vcpu->arch.exception.has_error_code;
+	error_code = vcpu->arch.exception.error_code;
+	intr_info = nr | INTR_INFO_VALID_MASK;
+
+	kvm_deliver_exception_payload(vcpu);
+
+	if (has_error_code) {
+		td_vmcs_write32(tdx, VM_ENTRY_EXCEPTION_ERROR_CODE,
+				error_code);
+		intr_info |= INTR_INFO_DELIVER_CODE_MASK;
+	}
+
+	if (kvm_exception_is_soft(nr)) {
+		td_vmcs_write32(tdx, VM_ENTRY_INSTRUCTION_LEN,
+				vcpu->arch.event_exit_inst_len);
+		intr_info |= INTR_TYPE_SOFT_EXCEPTION;
+	} else {
+		intr_info |= INTR_TYPE_HARD_EXCEPTION;
+	}
+
+	pr_info("%s: injected: 0x%x\n", __func__, intr_info);
+	td_vmcs_write32(tdx, VM_ENTRY_INTR_INFO_FIELD, intr_info);
+}
+
 static int tdx_handle_external_interrupt(struct kvm_vcpu *vcpu)
 {
 	++vcpu->stat.irq_exits;
diff --git a/arch/x86/kvm/vmx/tdx_stubs.c b/arch/x86/kvm/vmx/tdx_stubs.c
index cf3a9a71ad97..f6921325a21b 100644
--- a/arch/x86/kvm/vmx/tdx_stubs.c
+++ b/arch/x86/kvm/vmx/tdx_stubs.c
@@ -51,3 +51,4 @@ static void tdx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var,
 			    int seg) {}
 static void tdx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask) {}
 static int tdx_skip_emulated_instruction(struct kvm_vcpu *vcpu) { return 0; }
+static void tdx_queue_exception(struct kvm_vcpu *vcpu) {}
-- 
2.31.1

