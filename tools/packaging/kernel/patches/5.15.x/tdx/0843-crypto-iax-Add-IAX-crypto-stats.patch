From 53c0c99584172e61f3dec6cc64377537cc7f0cbc Mon Sep 17 00:00:00 2001
From: Tom Zanussi <tom.zanussi@linux.intel.com>
Date: Tue, 21 Sep 2021 15:59:56 -0700
Subject: [PATCH 0843/1418] crypto: iax - Add IAX crypto stats

Add support for optional debugfs statistics support.  This is enabled
by the kernel config item:

  IAX_CRYPTO_STATS

When enabled, the IAX crypto driver will generate statistics which can
be accessed at:

  /sys/kernel/debug/iax-crypto/

[ Based on work originally by George Powley and Jing Lin. ]

Co-developed-by: Kyung Min Park <kyung.min.park@intel.com>
Signed-off-by: Kyung Min Park <kyung.min.park@intel.com>
Signed-off-by: Tom Zanussi <tom.zanussi@linux.intel.com>
---
 drivers/crypto/iax/Kconfig            |   7 +
 drivers/crypto/iax/Makefile           |   2 +
 drivers/crypto/iax/iax_crypto.h       |  41 ++++
 drivers/crypto/iax/iax_crypto_main.c  |  80 ++++++--
 drivers/crypto/iax/iax_crypto_stats.c | 269 ++++++++++++++++++++++++++
 drivers/crypto/iax/iax_crypto_stats.h |  54 ++++++
 6 files changed, 438 insertions(+), 15 deletions(-)
 create mode 100644 drivers/crypto/iax/iax_crypto_stats.c
 create mode 100644 drivers/crypto/iax/iax_crypto_stats.h

diff --git a/drivers/crypto/iax/Kconfig b/drivers/crypto/iax/Kconfig
index e546d5952486..20bce91a9dbf 100644
--- a/drivers/crypto/iax/Kconfig
+++ b/drivers/crypto/iax/Kconfig
@@ -6,3 +6,10 @@ config CRYPTO_DEV_IAX_CRYPTO
 	help
 	  This driver supports Intel analytics accelerator hardware.
 	  The module will be called iax_crypto.
+
+config CRYPTO_DEV_IAX_CRYPTO_STATS
+	bool "IAX Crypto Stats"
+	depends on CRYPTO_DEV_IAX_CRYPTO
+	default n
+	help
+	  Enable IAX crypto stats
diff --git a/drivers/crypto/iax/Makefile b/drivers/crypto/iax/Makefile
index d0f3c1af8c73..532ac9002f9c 100644
--- a/drivers/crypto/iax/Makefile
+++ b/drivers/crypto/iax/Makefile
@@ -7,3 +7,5 @@ ccflags-y += -I $(srctree)/drivers/dma/idxd -DDEFAULT_SYMBOL_NAMESPACE=IDXD
 
 obj-$(CONFIG_CRYPTO_DEV_IAX_CRYPTO) := iax_crypto.o
 iax_crypto-y := iax_crypto_main.o
+
+iax_crypto-$(CONFIG_CRYPTO_DEV_IAX_CRYPTO_STATS) += iax_crypto_stats.o
diff --git a/drivers/crypto/iax/iax_crypto.h b/drivers/crypto/iax/iax_crypto.h
index 30771be44a0b..30137c27aef5 100644
--- a/drivers/crypto/iax/iax_crypto.h
+++ b/drivers/crypto/iax/iax_crypto.h
@@ -7,6 +7,7 @@
 #include <linux/crypto.h>
 #include <linux/idxd.h>
 #include <uapi/linux/idxd.h>
+#include "iax_crypto_stats.h"
 
 #undef pr_fmt
 #define	pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
@@ -37,6 +38,32 @@
 					 IAX_DECOMP_CHECK_FOR_EOB | \
 					 IAX_DECOMP_STOP_ON_EOB)
 
+struct iax_wq {
+	struct list_head	list;
+	struct idxd_wq		*wq;
+
+	struct iax_device	*iax_device;
+
+	u64			comp_calls;
+	u64			comp_bytes;
+	u64			decomp_calls;
+	u64			decomp_bytes;
+};
+
+/* Representation of IAX device with wqs, populated by probe */
+struct iax_device {
+	struct list_head	list;
+	struct idxd_device	*idxd;
+
+	int			n_wq;
+	struct list_head	wqs;
+
+	u64			comp_calls;
+	u64			comp_bytes;
+	u64			decomp_calls;
+	u64			decomp_bytes;
+};
+
 /*
  * Analytics Engine Configuration and State (AECS) contains parameters and
  * internal state of the analytics engine.
@@ -53,4 +80,18 @@ struct aecs_table_record {
 	u32 d_sym[30];
 	u32 reserved_padding[2];
 };
+
+#if defined(CONFIG_CRYPTO_DEV_IAX_CRYPTO_STATS)
+void	global_stats_show(struct seq_file *m);
+void	device_stats_show(struct seq_file *m, struct iax_device *iax_device);
+void	reset_iax_crypto_stats(void);
+void	reset_device_stats(struct iax_device *iax_device);
+
+#else
+static inline void	global_stats_show(struct seq_file *m) {}
+static inline void	device_stats_show(struct seq_file *m, struct iax_device *iax_device) {}
+static inline void	reset_iax_crypto_stats(void) {}
+static inline void	reset_device_stats(struct iax_device *iax_device) {}
+#endif
+
 #endif
diff --git a/drivers/crypto/iax/iax_crypto_main.c b/drivers/crypto/iax/iax_crypto_main.c
index fd25632fc399..961c6c83a7b6 100644
--- a/drivers/crypto/iax/iax_crypto_main.c
+++ b/drivers/crypto/iax/iax_crypto_main.c
@@ -36,24 +36,40 @@ module_param_named(iax_verify_compress, iax_verify_compress, bool, 0644);
 MODULE_PARM_DESC(iax_verify_compress,
 		 "Verify IAX compression (value = 1) or not (value = 0)");
 
-struct iax_wq {
-	struct list_head	list;
-	struct idxd_wq		*wq;
+static LIST_HEAD(iax_devices);
+static DEFINE_SPINLOCK(iax_devices_lock);
 
-	struct iax_device	*iax_device;
-};
+int wq_stats_show(struct seq_file *m, void *v)
+{
+	struct iax_device *iax_device;
 
-/* Representation of IAX device with wqs, populated by probe */
-struct iax_device {
-	struct list_head		list;
-	struct idxd_device		*idxd;
+	spin_lock(&iax_devices_lock);
 
-	int				n_wq;
-	struct list_head		wqs;
-};
+	global_stats_show(m);
 
-static LIST_HEAD(iax_devices);
-static DEFINE_SPINLOCK(iax_devices_lock);
+	list_for_each_entry(iax_device, &iax_devices, list)
+		device_stats_show(m, iax_device);
+
+	spin_unlock(&iax_devices_lock);
+
+	return 0;
+}
+
+int iax_crypto_stats_reset(void *data, u64 value)
+{
+	struct iax_device *iax_device;
+
+	reset_iax_crypto_stats();
+
+	spin_lock(&iax_devices_lock);
+
+	list_for_each_entry(iax_device, &iax_devices, list)
+		reset_device_stats(iax_device);
+
+	spin_unlock(&iax_devices_lock);
+
+	return 0;
+}
 
 static struct iax_device *iax_device_alloc(void)
 {
@@ -72,8 +88,10 @@ static void iax_device_free(struct iax_device *iax_device)
 {
 	struct iax_wq *iax_wq, *next;
 
-	list_for_each_entry_safe(iax_wq, next, &iax_device->wqs, list)
+	list_for_each_entry_safe(iax_wq, next, &iax_device->wqs, list) {
 		list_del(&iax_wq->list);
+		kfree(iax_wq); // zzzz do this in original code too
+	}
 
 	kfree(iax_device);
 }
@@ -416,6 +434,7 @@ static inline int check_completion(struct iax_completion_record *comp,
 			ret = -ETIMEDOUT;
 			pr_warn("%s: %s timed out, size=0x%x\n",
 				__func__, op_str, comp->output_size);
+			update_completion_timeout_errs();
 			goto out;
 		}
 
@@ -424,6 +443,7 @@ static inline int check_completion(struct iax_completion_record *comp,
 		    compress == true) {
 			ret = -E2BIG;
 			pr_debug("%s: compressed size > uncompressed size, not compressing, size=0x%x\n", __func__, comp->output_size);
+			update_completion_comp_buf_overflow_errs();
 			goto out;
 		}
 
@@ -431,6 +451,8 @@ static inline int check_completion(struct iax_completion_record *comp,
 		pr_err("%s: iax %s status=0x%x, error=0x%x, size=0x%x\n",
 		       __func__, op_str, ret, comp->error_code, comp->output_size);
 		print_hex_dump(KERN_INFO, "cmp-rec: ", DUMP_PREFIX_OFFSET, 8, 1, comp, 64, 0);
+		update_completion_einval_errs();
+
 		goto out;
 	}
 out:
@@ -500,6 +522,12 @@ static int iax_compress(struct crypto_tfm *tfm,
 
 	compression_crc = idxd_desc->iax_completion->crc;
 
+	/* Update stats */
+	update_total_comp_calls();
+	update_total_comp_bytes_out(*dlen);
+	update_wq_comp_calls(wq);
+	update_wq_comp_bytes(wq, *dlen);
+
 	idxd_desc = idxd_alloc_desc(wq, IDXD_OP_BLOCK);
 	if (IS_ERR(idxd_desc)) {
 		pr_err("%s: idxd descriptor allocation failed\n", __func__);
@@ -606,6 +634,12 @@ static int iax_decompress(struct crypto_tfm *tfm,
 	*dlen = idxd_desc->iax_completion->output_size;
 
 	idxd_free_desc(wq, idxd_desc);
+
+	/* Update stats */
+	update_total_decomp_calls();
+	update_total_decomp_bytes_in(slen);
+	update_wq_decomp_calls(wq);
+	update_wq_decomp_bytes(wq, slen);
 out:
 	return ret;
 err:
@@ -619,12 +653,15 @@ static int iax_comp_compress(struct crypto_tfm *tfm,
 			     const u8 *src, unsigned int slen,
 			     u8 *dst, unsigned int *dlen)
 {
+	u64 start_time_ns;
 	int ret;
 
 	pr_debug("%s: src %p, slen %d, dst %p, dlen %u\n",
 		 __func__, src, slen, dst, *dlen);
 
+	start_time_ns = ktime_get_ns();
 	ret = iax_compress(tfm, src, slen, dst, dlen);
+	update_max_comp_delay_ns(start_time_ns);
 	if (ret != 0)
 		pr_warn("synchronous compress failed ret=%d\n", ret);
 
@@ -635,12 +672,15 @@ static int iax_comp_decompress(struct crypto_tfm *tfm,
 			       const u8 *src, unsigned int slen,
 			       u8 *dst, unsigned int *dlen)
 {
+	u64 start_time_ns;
 	int ret;
 
 	pr_debug("%s: src %p, slen %d, dst %p, dlen %u\n",
 		 __func__, src, slen, dst, *dlen);
 
+	start_time_ns = ktime_get_ns();
 	ret = iax_decompress(tfm, src, slen, dst, dlen);
+	update_max_decomp_delay_ns(start_time_ns);
 	if (ret != 0)
 		pr_warn("synchronous decompress failed ret=%d\n", ret);
 
@@ -664,6 +704,7 @@ static struct crypto_alg iax_comp_deflate = {
 static int iax_comp_acompress(struct acomp_req *req)
 {
 	struct crypto_tfm *tfm = req->base.tfm;
+	u64 start_time_ns;
 	void *src, *dst;
 	int ret;
 
@@ -674,7 +715,9 @@ static int iax_comp_acompress(struct acomp_req *req)
 		 __func__, src, req->src->offset, req->slen,
 		 dst, req->dst->offset, req->dlen);
 
+	start_time_ns = ktime_get_ns();
 	ret = iax_compress(tfm, (const u8 *)src, req->slen, (u8 *)dst, &req->dlen);
+	update_max_acomp_delay_ns(start_time_ns);
 
 	kunmap_atomic(src);
 	kunmap_atomic(dst);
@@ -688,6 +731,7 @@ static int iax_comp_acompress(struct acomp_req *req)
 static int iax_comp_adecompress(struct acomp_req *req)
 {
 	struct crypto_tfm *tfm = req->base.tfm;
+	u64 start_time_ns;
 	void *src, *dst;
 	int ret;
 
@@ -698,7 +742,9 @@ static int iax_comp_adecompress(struct acomp_req *req)
 		 __func__, src, req->src->offset, req->slen,
 		 dst, req->dst->offset, req->dlen);
 
+	start_time_ns = ktime_get_ns();
 	ret = iax_decompress(tfm, (const u8 *)src, req->slen, (u8 *)dst, &req->dlen);
+	update_max_decomp_delay_ns(start_time_ns);
 
 	kunmap_atomic(src);
 	kunmap_atomic(dst);
@@ -909,6 +955,9 @@ static int __init iax_crypto_init_module(void)
 		goto err_crypto_register;
 	}
 
+	if (iax_crypto_debugfs_init())
+		pr_warn("debugfs init failed, stats not available\n");
+
 	pr_info("%s: initialized\n", __func__);
 out:
 	return ret;
@@ -923,6 +972,7 @@ static int __init iax_crypto_init_module(void)
 
 static void __exit iax_crypto_cleanup_module(void)
 {
+	iax_crypto_debugfs_cleanup();
 	idxd_driver_unregister(&iax_crypto_driver);
 	iax_unregister_compression_device();
 	free_percpu(wq_table);
diff --git a/drivers/crypto/iax/iax_crypto_stats.c b/drivers/crypto/iax/iax_crypto_stats.c
new file mode 100644
index 000000000000..525a20d12cc5
--- /dev/null
+++ b/drivers/crypto/iax/iax_crypto_stats.c
@@ -0,0 +1,269 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 2021 Intel Corporation. All rights rsvd. */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/highmem.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/smp.h>
+#include <uapi/linux/idxd.h>
+#include <linux/idxd.h>
+#include <linux/dmaengine.h>
+#include <linux/intel-svm.h>
+#include "../../dma/idxd/idxd.h"
+#include <linux/debugfs.h>
+#include <crypto/internal/acompress.h>
+#include "iax_crypto.h"
+#include "iax_crypto_stats.h"
+
+static u64 total_comp_calls;
+static u64 total_decomp_calls;
+static u64 max_comp_delay_ns;
+static u64 max_decomp_delay_ns;
+static u64 max_acomp_delay_ns;
+static u64 max_adecomp_delay_ns;
+static u64 total_comp_bytes_out;
+static u64 total_decomp_bytes_in;
+static u64 total_completion_einval_errors;
+static u64 total_completion_timeout_errors;
+static u64 total_completion_comp_buf_overflow_errors;
+
+static struct dentry *iax_crypto_debugfs_root;
+
+void update_total_comp_calls(void)
+{
+	total_comp_calls++;
+}
+
+void update_total_comp_bytes_out(int n)
+{
+	total_comp_bytes_out += n;
+}
+
+void update_total_decomp_calls(void)
+{
+	total_decomp_calls++;
+}
+
+void update_total_decomp_bytes_in(int n)
+{
+	total_decomp_bytes_in += n;
+}
+
+void update_completion_einval_errs(void)
+{
+	total_completion_einval_errors++;
+}
+
+void update_completion_timeout_errs(void)
+{
+	total_completion_timeout_errors++;
+}
+
+void update_completion_comp_buf_overflow_errs(void)
+{
+	total_completion_comp_buf_overflow_errors++;
+}
+
+void update_max_comp_delay_ns(u64 start_time_ns)
+{
+	u64 time_diff;
+
+	time_diff = ktime_get_ns() - start_time_ns;
+
+	if (time_diff > max_comp_delay_ns)
+		max_comp_delay_ns = time_diff;
+}
+
+void update_max_decomp_delay_ns(u64 start_time_ns)
+{
+	u64 time_diff;
+
+	time_diff = ktime_get_ns() - start_time_ns;
+
+	if (time_diff > max_decomp_delay_ns)
+		max_decomp_delay_ns = time_diff;
+}
+
+void update_max_acomp_delay_ns(u64 start_time_ns)
+{
+	u64 time_diff;
+
+	time_diff = ktime_get_ns() - start_time_ns;
+
+	if (time_diff > max_acomp_delay_ns)
+		max_acomp_delay_ns = time_diff;
+}
+
+void update_max_adecomp_delay_ns(u64 start_time_ns)
+{
+	u64 time_diff;
+
+	time_diff = ktime_get_ns() - start_time_ns;
+
+	if (time_diff > max_adecomp_delay_ns)
+
+		max_adecomp_delay_ns = time_diff;
+}
+
+void update_wq_comp_calls(struct idxd_wq *idxd_wq)
+{
+	struct iax_wq *wq = idxd_wq->private_data;
+
+	wq->comp_calls++;
+	wq->iax_device->comp_calls++;
+}
+
+void update_wq_comp_bytes(struct idxd_wq *idxd_wq, int n)
+{
+	struct iax_wq *wq = idxd_wq->private_data;
+
+	wq->comp_bytes += n;
+	wq->iax_device->comp_bytes += n;
+}
+
+void update_wq_decomp_calls(struct idxd_wq *idxd_wq)
+{
+	struct iax_wq *wq = idxd_wq->private_data;
+
+	wq->decomp_calls++;
+	wq->iax_device->decomp_calls++;
+}
+
+void update_wq_decomp_bytes(struct idxd_wq *idxd_wq, int n)
+{
+	struct iax_wq *wq = idxd_wq->private_data;
+
+	wq->decomp_bytes += n;
+	wq->iax_device->decomp_bytes += n;
+}
+
+void reset_iax_crypto_stats(void)
+{
+	total_comp_calls = 0;
+	total_decomp_calls = 0;
+	max_comp_delay_ns = 0;
+	max_decomp_delay_ns = 0;
+	max_acomp_delay_ns = 0;
+	max_adecomp_delay_ns = 0;
+	total_comp_bytes_out = 0;
+	total_decomp_bytes_in = 0;
+	total_completion_einval_errors = 0;
+	total_completion_timeout_errors = 0;
+	total_completion_comp_buf_overflow_errors = 0;
+}
+
+static void reset_wq_stats(struct iax_wq *wq)
+{
+	wq->comp_calls = 0;
+	wq->comp_bytes = 0;
+	wq->decomp_calls = 0;
+	wq->decomp_bytes = 0;
+}
+
+void reset_device_stats(struct iax_device *iax_device)
+{
+	struct iax_wq *iax_wq;
+
+	iax_device->comp_calls = 0;
+	iax_device->comp_bytes = 0;
+	iax_device->decomp_calls = 0;
+	iax_device->decomp_bytes = 0;
+
+	list_for_each_entry(iax_wq, &iax_device->wqs, list)
+		reset_wq_stats(iax_wq);
+}
+
+static void wq_show(struct seq_file *m, struct iax_wq *iax_wq)
+{
+	seq_printf(m, "    name: %s\n", iax_wq->wq->name);
+	seq_printf(m, "    comp_calls: %llu\n", iax_wq->comp_calls);
+	seq_printf(m, "    comp_bytes: %llu\n", iax_wq->comp_bytes);
+	seq_printf(m, "    decomp_calls: %llu\n", iax_wq->decomp_calls);
+	seq_printf(m, "    decomp_bytes: %llu\n\n", iax_wq->decomp_bytes);
+}
+
+void device_stats_show(struct seq_file *m, struct iax_device *iax_device)
+{
+	struct iax_wq *iax_wq;
+
+	seq_puts(m, "iax device:\n");
+	seq_printf(m, "  id: %d\n", iax_device->idxd->id);
+	seq_printf(m, "  n_wqs: %d\n", iax_device->n_wq);
+	seq_printf(m, "  comp_calls: %llu\n", iax_device->comp_calls);
+	seq_printf(m, "  comp_bytes: %llu\n", iax_device->comp_bytes);
+	seq_printf(m, "  decomp_calls: %llu\n", iax_device->decomp_calls);
+	seq_printf(m, "  decomp_bytes: %llu\n", iax_device->decomp_bytes);
+	seq_puts(m, "  wqs:\n");
+
+	list_for_each_entry(iax_wq, &iax_device->wqs, list)
+		wq_show(m, iax_wq);
+}
+
+void global_stats_show(struct seq_file *m)
+{
+	seq_puts(m, "global stats:\n");
+	seq_printf(m, "  total_comp_calls: %llu\n", total_comp_calls);
+	seq_printf(m, "  total_decomp_calls: %llu\n", total_decomp_calls);
+	seq_printf(m, "  total_comp_bytes_out: %llu\n", total_comp_bytes_out);
+	seq_printf(m, "  total_decomp_bytes_in: %llu\n", total_decomp_bytes_in);
+	seq_printf(m, "  total_completion_einval_errors: %llu\n", total_completion_einval_errors);
+	seq_printf(m, "  total_completion_timeout_errors: %llu\n", total_completion_timeout_errors);
+	seq_printf(m, "  total_completion_comp_buf_overflow_errors: %llu\n\n", total_completion_comp_buf_overflow_errors);
+}
+
+static int wq_stats_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, wq_stats_show, file);
+}
+
+const struct file_operations wq_stats_fops = {
+	.open = wq_stats_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+DEFINE_DEBUGFS_ATTRIBUTE(wq_stats_reset_fops, NULL, iax_crypto_stats_reset, "%llu\n");
+
+int __init iax_crypto_debugfs_init(void)
+{
+	if (!debugfs_initialized())
+		return -ENODEV;
+
+	iax_crypto_debugfs_root = debugfs_create_dir("iax_crypto", NULL);
+	if (!iax_crypto_debugfs_root)
+		return -ENOMEM;
+
+	debugfs_create_u64("max_comp_delay_ns", 0644,
+			   iax_crypto_debugfs_root, &max_comp_delay_ns);
+	debugfs_create_u64("max_decomp_delay_ns", 0644,
+			   iax_crypto_debugfs_root, &max_decomp_delay_ns);
+	debugfs_create_u64("max_acomp_delay_ns", 0644,
+			   iax_crypto_debugfs_root, &max_comp_delay_ns);
+	debugfs_create_u64("max_adecomp_delay_ns", 0644,
+			   iax_crypto_debugfs_root, &max_decomp_delay_ns);
+	debugfs_create_u64("total_comp_calls", 0644,
+			   iax_crypto_debugfs_root, &total_comp_calls);
+	debugfs_create_u64("total_decomp_calls", 0644,
+			   iax_crypto_debugfs_root, &total_decomp_calls);
+	debugfs_create_u64("total_comp_bytes_out", 0644,
+			   iax_crypto_debugfs_root, &total_comp_bytes_out);
+	debugfs_create_u64("total_decomp_bytes_in", 0644,
+			   iax_crypto_debugfs_root, &total_decomp_bytes_in);
+	debugfs_create_file("wq_stats", 0644, iax_crypto_debugfs_root, NULL,
+			    &wq_stats_fops);
+	debugfs_create_file("wq_stats_reset", 0644, iax_crypto_debugfs_root, NULL,
+			    &wq_stats_reset_fops);
+
+	return 0;
+}
+
+void __exit iax_crypto_debugfs_cleanup(void)
+{
+	debugfs_remove_recursive(iax_crypto_debugfs_root);
+}
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/crypto/iax/iax_crypto_stats.h b/drivers/crypto/iax/iax_crypto_stats.h
new file mode 100644
index 000000000000..524f444e58ff
--- /dev/null
+++ b/drivers/crypto/iax/iax_crypto_stats.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2021 Intel Corporation. All rights rsvd. */
+
+#ifndef __CRYPTO_DEV_IAX_CRYPTO_STATS_H__
+#define __CRYPTO_DEV_IAX_CRYPTO_STATS_H__
+
+#if defined(CONFIG_CRYPTO_DEV_IAX_CRYPTO_STATS)
+int	iax_crypto_debugfs_init(void);
+void	iax_crypto_debugfs_cleanup(void);
+
+void	update_total_comp_calls(void);
+void	update_total_comp_bytes_out(int n);
+void	update_total_decomp_calls(void);
+void	update_total_decomp_bytes_in(int n);
+void	update_max_comp_delay_ns(u64 start_time_ns);
+void	update_max_decomp_delay_ns(u64 start_time_ns);
+void	update_max_acomp_delay_ns(u64 start_time_ns);
+void	update_max_adecomp_delay_ns(u64 start_time_ns);
+void	update_completion_einval_errs(void);
+void	update_completion_timeout_errs(void);
+void	update_completion_comp_buf_overflow_errs(void);
+
+void	update_wq_comp_calls(struct idxd_wq *idxd_wq);
+void	update_wq_comp_bytes(struct idxd_wq *idxd_wq, int n);
+void	update_wq_decomp_calls(struct idxd_wq *idxd_wq);
+void	update_wq_decomp_bytes(struct idxd_wq *idxd_wq, int n);
+
+int	wq_stats_show(struct seq_file *m, void *v);
+int	iax_crypto_stats_reset(void *data, u64 value);
+
+#else
+static inline int	iax_crypto_debugfs_init(void) { return 0; }
+static inline void	iax_crypto_debugfs_cleanup(void) {}
+
+static inline void	update_total_comp_calls(void) {}
+static inline void	update_total_comp_bytes_out(int n) {}
+static inline void	update_total_decomp_calls(void) {}
+static inline void	update_total_decomp_bytes_in(int n) {}
+static inline void	update_max_comp_delay_ns(u64 start_time_ns) {}
+static inline void	update_max_decomp_delay_ns(u64 start_time_ns) {}
+static inline void	update_max_acomp_delay_ns(u64 start_time_ns) {}
+static inline void	update_max_adecomp_delay_ns(u64 start_time_ns) {}
+static inline void	update_completion_einval_errs(void) {}
+static inline void	update_completion_timeout_errs(void) {}
+static inline void	update_completion_comp_buf_overflow_errs(void) {}
+
+static inline void	update_wq_comp_calls(struct idxd_wq *idxd_wq) {}
+static inline void	update_wq_comp_bytes(struct idxd_wq *idxd_wq, int n) {}
+static inline void	update_wq_decomp_calls(struct idxd_wq *idxd_wq) {}
+static inline void	update_wq_decomp_bytes(struct idxd_wq *idxd_wq, int n) {}
+
+#endif // CONFIG_CRYPTO_DEV_IAX_CRYPTO_STATS
+
+#endif
-- 
2.31.1

