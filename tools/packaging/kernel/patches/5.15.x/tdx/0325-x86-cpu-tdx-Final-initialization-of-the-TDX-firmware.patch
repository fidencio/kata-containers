From 25c8f727b1c7c7f627b9f285bf2c8291657194a2 Mon Sep 17 00:00:00 2001
From: Isaku Yamahata <isaku.yamahata@intel.com>
Date: Wed, 29 Sep 2021 15:35:17 -0700
Subject: [PATCH 0325/1418] x86/cpu/tdx: Final initialization of the TDX
 firmware

The final initialization of the TDX firmware module.  Construct memory
region usable as TDX memory(TDMR), initialize the TDMR and the TDX
metadata(PAMT) for the TDX firmware module and configure encryption key on
each CPU package.

Introduce a feature flag, X86_FEATURE_TDX, to denote that the TDX module is
initialized and configured successfully, and the TDX module is supported to
respond to more SEAMCALLs of a TD guest.

Co-developed-by: Kai Huang <kai.huang@intel.com>
Signed-off-by: Kai Huang <kai.huang@intel.com>
Co-developed-by: Chao Gao <chao.gao@intel.com>
Signed-off-by: Chao Gao <chao.gao@intel.com>
Signed-off-by: Isaku Yamahata <isaku.yamahata@intel.com>
---
 arch/x86/include/asm/cpufeatures.h |   1 +
 arch/x86/include/asm/tdx_arch.h    |   3 +
 arch/x86/include/asm/tdx_errno.h   |   4 +-
 arch/x86/include/asm/tdx_host.h    |   7 +
 arch/x86/kernel/cpu/tdx/tdx-ops.h  |  21 ++
 arch/x86/kernel/cpu/tdx/tdx.c      | 336 ++++++++++++++++++++++++++++-
 6 files changed, 368 insertions(+), 4 deletions(-)

diff --git a/arch/x86/include/asm/cpufeatures.h b/arch/x86/include/asm/cpufeatures.h
index 15ffa2638a95..a799d70c8909 100644
--- a/arch/x86/include/asm/cpufeatures.h
+++ b/arch/x86/include/asm/cpufeatures.h
@@ -231,6 +231,7 @@
 #define X86_FEATURE_EPT			( 8*32+ 3) /* Intel Extended Page Table */
 #define X86_FEATURE_VPID		( 8*32+ 4) /* Intel Virtual Processor ID */
 #define X86_FEATURE_SEAM		( 8*32+ 5) /* "" Secure Arbitration Mode */
+#define X86_FEATURE_TDX			( 8*32+ 6) /* Intel Trusted Domain eXtensions */
 
 #define X86_FEATURE_VMMCALL		( 8*32+15) /* Prefer VMMCALL to VMCALL */
 #define X86_FEATURE_XENPV		( 8*32+16) /* "" Xen paravirtual guest */
diff --git a/arch/x86/include/asm/tdx_arch.h b/arch/x86/include/asm/tdx_arch.h
index 07408b724540..f4bce0b1ad2a 100644
--- a/arch/x86/include/asm/tdx_arch.h
+++ b/arch/x86/include/asm/tdx_arch.h
@@ -9,9 +9,12 @@
 /*
  * TDX SEAMCALL API function leaves
  */
+#define SEAMCALL_TDH_SYS_KEY_CONFIG		31
 #define SEAMCALL_TDH_SYS_INFO			32
 #define SEAMCALL_TDH_SYS_INIT			33
 #define SEAMCALL_TDH_SYS_LP_INIT		35
+#define SEAMCALL_TDH_SYS_TDMR_INIT		36
+#define SEAMCALL_TDH_SYS_CONFIG			45
 
 #define TDX_MAX_NR_CMRS			32
 #define TDX_MAX_NR_TDMRS		64
diff --git a/arch/x86/include/asm/tdx_errno.h b/arch/x86/include/asm/tdx_errno.h
index 0e419855c147..a8b2cd26817a 100644
--- a/arch/x86/include/asm/tdx_errno.h
+++ b/arch/x86/include/asm/tdx_errno.h
@@ -10,10 +10,12 @@
  * TDX SEAMCALL Status Codes (returned in RAX)
  */
 #define TDX_SUCCESS				0x0000000000000000ULL
+#define TDX_KEY_GENERATION_FAILED		0x8000080000000000ULL
 
 #define TDX_STATUS_CODE(name)	{ name, #name }
 
 #define TDX_STATUS_CODES					\
-	TDX_STATUS_CODE(TDX_SUCCESS)
+	TDX_STATUS_CODE(TDX_SUCCESS),				\
+	TDX_STATUS_CODE(TDX_KEY_GENERATION_FAILED)
 
 #endif /* __ASM_X86_TDX_ERRNO_H */
diff --git a/arch/x86/include/asm/tdx_host.h b/arch/x86/include/asm/tdx_host.h
index 0dc05b050de4..4c74a5f65711 100644
--- a/arch/x86/include/asm/tdx_host.h
+++ b/arch/x86/include/asm/tdx_host.h
@@ -33,6 +33,11 @@ struct tdx_ex_ret {
 			u64 cmr_info;
 			u64 nr_cmr_entries;
 		} sys_info;
+		/* TDH_SYS_TDMR_INIT returns the input PA and next PA. */
+		struct {
+			u64 prev;
+			u64 next;
+		} sys_tdmr_init;
 	};
 };
 
@@ -47,6 +52,8 @@ int tdx_seamcall_on_each_pkg(int (*fn)(void *), void *param);
 
 extern u32 tdx_keyids_start __read_mostly;
 extern u32 tdx_nr_keyids __read_mostly;
+extern u32 tdx_seam_keyid __read_mostly;
+
 #else
 static inline const char *tdx_seamcall_error_name(u64 error_code)
 {
diff --git a/arch/x86/kernel/cpu/tdx/tdx-ops.h b/arch/x86/kernel/cpu/tdx/tdx-ops.h
index a939f016c4f7..1efca41a7c1f 100644
--- a/arch/x86/kernel/cpu/tdx/tdx-ops.h
+++ b/arch/x86/kernel/cpu/tdx/tdx-ops.h
@@ -3,6 +3,11 @@
 #ifndef __TDX_OPS_H
 #define __TDX_OPS_H
 
+static inline u64 tdh_sys_key_config(void)
+{
+	return seamcall(SEAMCALL_TDH_SYS_KEY_CONFIG, 0, 0, 0, 0, NULL);
+}
+
 static inline u64 tdh_sys_info(u64 tdsysinfo, int nr_bytes, u64 cmr_info,
 			       int nr_cmr_entries, struct tdx_ex_ret *ex)
 {
@@ -20,4 +25,20 @@ static inline u64 tdh_sys_lp_init(struct tdx_ex_ret *ex)
 	return seamcall(SEAMCALL_TDH_SYS_LP_INIT, 0, 0, 0, 0, ex);
 }
 
+static inline u64 tdh_sys_tdmr_init(u64 tdmr, struct tdx_ex_ret *ex)
+{
+	return seamcall(SEAMCALL_TDH_SYS_TDMR_INIT, tdmr, 0, 0, 0, ex);
+}
+
+/*
+ * Rename TDH_SYS_CONFIG that is defined in TDX module spec to
+ * tdh_sys_tdmr_config because the original name is misleading.  It configures
+ * TDMRs to use and global private HKID.
+ */
+static inline u64 tdh_sys_tdmr_config(u64 tdmr, int nr_entries, int hkid)
+{
+	return seamcall(SEAMCALL_TDH_SYS_CONFIG, tdmr, nr_entries, hkid, 0,
+			     NULL);
+}
+
 #endif /* __TDX_OPS_H */
diff --git a/arch/x86/kernel/cpu/tdx/tdx.c b/arch/x86/kernel/cpu/tdx/tdx.c
index a52518a8a6e5..19b3172a4b74 100644
--- a/arch/x86/kernel/cpu/tdx/tdx.c
+++ b/arch/x86/kernel/cpu/tdx/tdx.c
@@ -10,6 +10,9 @@
 #include <linux/slab.h>
 #include <linux/cpu.h>
 
+#include <asm/irq_vectors.h>
+#include <asm/trace/seam.h>
+#include <asm/tdx_errno.h>
 #include <asm/tdx_arch.h>
 #include <asm/tdx_host.h>
 #include <asm/virtext.h>
@@ -143,6 +146,8 @@ u32 tdx_keyids_start __read_mostly;
 EXPORT_SYMBOL_GPL(tdx_keyids_start);	/* kvm_intel will use this. */
 u32 tdx_nr_keyids __read_mostly;
 EXPORT_SYMBOL_GPL(tdx_nr_keyids);	/* kvm_intel will use this. */
+u32 tdx_seam_keyid __read_mostly;
+EXPORT_SYMBOL_GPL(tdx_seam_keyid);	/* kvm_intel will use this. */
 
 static void __init tdx_get_keyids(u32 *keyids_start, u32 *nr_keyids)
 {
@@ -767,13 +772,276 @@ static int __init tdx_arch_init(void)
  */
 arch_initcall(tdx_arch_init);
 
+/* Array of all TDMR info array. */
+static struct tdmr_info *tdmr_info __initdata; /* aligned to TDX_TDMR_INFO_ALIGNMENT. */
+/* Number of actual TDMRs */
+static int tdx_nr_tdmrs __initdata;
+
+/* data structure for tdx_init_tdmrs() */
+struct tdx_tdmr_init_data {
+	struct mutex lock;
+	int next_tdmr_index;
+	int nr_initialized_tdmrs;
+	int failed;
+	int nr_completed;
+	int nr_works;
+	struct completion completion;
+};
+
+struct tdx_tdmr_init_request {
+	struct work_struct work;
+	struct tdx_tdmr_init_data *data;
+};
+
+/*
+ * __tdx_init_tdmrs - worker to initialize TDMRs
+ * @work: work_struct to work queue which embedded in tdx_tdmr_init_request.
+ *
+ * Get an uninitialized TDMR, initialize it and loop until all TDMRs are
+ * initialized.
+ */
+static void __init __tdx_init_tdmrs(struct work_struct *work)
+{
+	struct tdx_tdmr_init_request *req = container_of(
+		work, struct tdx_tdmr_init_request, work);
+	struct tdx_tdmr_init_data *data = req->data;
+	struct tdx_ex_ret ex_ret;
+	bool completed;
+	u64 base, size;
+	u64 err = 0;
+	int i;
+
+	mutex_lock(&data->lock);
+	while (data->next_tdmr_index < tdx_nr_tdmrs) {
+		i = data->next_tdmr_index++;
+		base = tdmr_info[i].base;
+		size = tdmr_info[i].size;
+
+		while (true) {
+			/* Abort if a different CPU failed. */
+			if (data->failed)
+				goto out;
+
+			mutex_unlock(&data->lock);
+			err = tdh_sys_tdmr_init(base, &ex_ret);
+			if (WARN_ON_ONCE(err)) {
+				pr_seamcall_error(SEAMCALL_TDH_SYS_TDMR_INIT,
+						  "TDH_SYS_TDMR_INIT", err,
+						  &ex_ret);
+				err = -EIO;
+				mutex_lock(&data->lock);
+				goto out;
+			}
+			cond_resched();
+			mutex_lock(&data->lock);
+
+			/*
+			 * Note, "next" is simply an indicator, base is passed
+			 * to TDH.SYS.TDMR.INIT on every iteration.
+			 */
+			if (!(ex_ret.sys_tdmr_init.next < (base + size)))
+				break;
+		}
+
+		data->nr_initialized_tdmrs++;
+	}
+
+out:
+	if (err)
+		data->failed++;
+	data->nr_completed++;
+	completed = (data->nr_completed == data->nr_works);
+	mutex_unlock(&data->lock);
+
+	if (completed)
+		complete(&data->completion);
+}
+
+/*
+ * tdx_init_tdmrs - Initializes TDMRs in parallel way.
+ * @return: 0 on success, error code on failure.
+ *
+ * It may take long time to initialize TDMRs by TDH.SYS.TDMR.INIT that
+ * initializes Physical Address Metadata Table(PAMT) which is something similar
+ * to Linux struct page.  Parallelize it to shorten boot time by work queue.
+ */
+static int __init tdx_init_tdmrs(void)
+{
+	/*
+	 * One TDMR can be initialized only by one thread.  No point to have
+	 * threads more than the number of TDMRs.
+	 */
+	int nr_works = min_t(int, num_online_cpus(), tdx_nr_tdmrs);
+	struct tdx_tdmr_init_data data = {
+		.next_tdmr_index = 0,
+		.nr_initialized_tdmrs = 0,
+		.failed = 0,
+		.nr_completed = 0,
+		.nr_works = nr_works,
+		.completion = COMPLETION_INITIALIZER_ONSTACK(data.completion),
+	};
+	int i;
+
+	struct tdx_tdmr_init_request *reqs = kcalloc(nr_works, sizeof(*reqs),
+						     GFP_KERNEL);
+	if (!reqs)
+		return -ENOMEM;
+
+	mutex_init(&data.lock);
+	for (i = 0; i < nr_works; i++) {
+		reqs[i].data = &data;
+		INIT_WORK(&reqs[i].work, __tdx_init_tdmrs);
+		queue_work(system_unbound_wq, &reqs[i].work);
+	}
+	wait_for_completion(&data.completion);
+
+	kfree(reqs);
+	mutex_lock(&data.lock);
+	if (data.failed || data.nr_initialized_tdmrs < tdx_nr_tdmrs) {
+		mutex_unlock(&data.lock);
+		return -EIO;
+	}
+	mutex_unlock(&data.lock);
+	return 0;
+}
+
+static int __init do_tdh_sys_key_config(void *param)
+{
+	u64 err;
+
+	do {
+		err = tdh_sys_key_config();
+	} while (err == TDX_KEY_GENERATION_FAILED);
+	if (WARN_ON_ONCE(err)) {
+		pr_seamcall_error(SEAMCALL_TDH_SYS_KEY_CONFIG,
+				  "TDH_SYS_KEY_CONFIG", err, NULL);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+/*
+ * __tdx_init_module - finial initialization of TDX module so that it can be
+ *                     workable.
+ */
+static int __init __tdx_init_module(void)
+{
+	u64 *tdmr_addrs;
+	u64 err;
+	int ret = 0;
+	int i;
+
+	/*
+	 * tdmr_addrs must be aligned to TDX_TDMR_ADDR_ALIGNMENT(512).
+	 * kmalloc() returns size-aligned when size is power of 2.
+	 */
+	BUILD_BUG_ON(!is_power_of_2(sizeof(*tdmr_addrs) * TDX_MAX_NR_TDMRS));
+	BUILD_BUG_ON(!IS_ALIGNED(sizeof(*tdmr_addrs) * TDX_MAX_NR_TDMRS,
+				 TDX_TDMR_ADDR_ALIGNMENT));
+	tdmr_addrs = kmalloc(sizeof(*tdmr_addrs) * TDX_MAX_NR_TDMRS, GFP_KERNEL);
+	if (!tdmr_addrs)
+		return -ENOMEM;
+
+	for (i = 0; i < tdx_nr_tdmrs; i++)
+		tdmr_addrs[i] = __pa(&tdmr_info[i]);
+
+	/*
+	 * tdh_sys_tdmr_config() calls TDH.SYS.CONFIG to tell TDX module about
+	 * TDMRs, PAMTs and HKID for TDX module to use.  Use the first keyID as
+	 * TDX-SEAM's global key.
+	 */
+	err = tdh_sys_tdmr_config(__pa(tdmr_addrs), tdx_nr_tdmrs,
+				  tdx_keyids_start);
+	if (WARN_ON_ONCE(err)) {
+		pr_seamcall_error(SEAMCALL_TDH_SYS_CONFIG, "TDH_SYS_CONFIG",
+				  err, NULL);
+		ret = -EIO;
+		goto out;
+	}
+	tdx_seam_keyid = tdx_keyids_start;
+
+	/*
+	 * Cache Flush is required as
+	 * TDX module spec: Chapter 12 Intel TDX Module Lifecycle Table 12.1
+	 */
+	wbinvd_on_all_cpus();
+
+	/* Cpuslock is already held by the caller. */
+	ret = tdx_seamcall_on_each_pkg_cpuslocked(do_tdh_sys_key_config, NULL);
+	if (ret)
+		goto out;
+
+	ret = tdx_init_tdmrs();
+out:
+	kfree(tdmr_addrs);
+	return ret;
+}
+
+static int __init tdx_init_module(void)
+{
+	struct tdx_module_descriptor desc;
+	int ret = 0;
+
+	/*
+	 * tdmr_info must be aligned to TDX_TDMR_INFO_ALIGNMENT(512).
+	 * NOTE: kmalloc() returns size-aligned when size of power of 2.
+	 */
+	BUILD_BUG_ON(sizeof(*tdmr_info) != 512);
+	BUILD_BUG_ON((sizeof(*tdmr_info) % TDX_TDMR_INFO_ALIGNMENT) != 0);
+	tdmr_info = kcalloc(tdx_tdsysinfo->max_tdmrs, sizeof(*tdmr_info),
+			GFP_KERNEL);
+	if (!tdmr_info) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* construct all TDMRs */
+	desc.max_tdmr_num = tdx_tdsysinfo->max_tdmrs;
+	desc.pamt_entry_size[TDX_PG_4K] = tdx_tdsysinfo->pamt_entry_size;
+	desc.pamt_entry_size[TDX_PG_2M] = tdx_tdsysinfo->pamt_entry_size;
+	desc.pamt_entry_size[TDX_PG_1G] = tdx_tdsysinfo->pamt_entry_size;
+	desc.max_tdmr_rsvd_area_num = tdx_tdsysinfo->max_reserved_per_tdmr;
+
+	ret = construct_tdx_tdmrs(tdx_cmrs, tdx_nr_cmrs, &desc, tdmr_info,
+			&tdx_nr_tdmrs);
+	if (ret)
+		goto out;
+
+	/* final initialization to make TDX module workable. */
+	ret = __tdx_init_module();
+	if (ret)
+		goto out;
+
+out:
+	return ret;
+}
+
+/*
+ * The final initialization of the TDX module and make it ready to use.
+ */
 static int __init tdx_late_init(void)
 {
-	int ret;
+	int vmxoff_err;
+	int ret = 0;
+
+	BUILD_BUG_ON(sizeof(struct tdmr_info) != 512);
 
 	if (tdx_module_state != TDX_MODULE_LOADED)
 		return -ENODEV;
 
+	pr_info("Initializing TDX module.\n");
+
+	/*
+	 * Since other subsystem(for example, ACPI subsystem) is initialized,
+	 * prevent potential concurrent CPU online/offline.
+	 *
+	 * - Protect tdx_package_leaders for per-package operation.
+	 * - Make seam_vmxon_on_each_cpu() work.  Otherwise concurrently onlined
+	 *   CPU has VMX disabled and the SEAM operation on that CPU fails.
+	 */
+	cpus_read_lock();
+
 	/*
 	 * Build legacy PMEMs as TDX memory in subsys_initcall_sync() here,
 	 * after e820__reserve_resources_late() is done, since it uses
@@ -781,12 +1049,74 @@ static int __init tdx_late_init(void)
 	 */
 	ret = tdx_legacy_pmem_build();
 	if (ret)
-		return ret;
+		goto out_err;
 
 	/*
 	 * Both TDX memory instances for system memory and legacy PMEMs are
 	 * ready.  Merge them into final TDX memory for constructing TDMRs.
 	 */
-	return build_final_tdx_memory();
+	ret = build_final_tdx_memory();
+	if (ret)
+		goto out_err;
+
+	/* SEAMCALL requires to enable VMXON on CPUs. */
+	ret = seam_alloc_init_vmcs_tmp_set();
+	if (ret)
+		goto out_err;
+	ret = seam_vmxon_on_each_cpu();
+	if (ret)
+		goto out;
+
+	ret = tdx_init_module();
+	if (ret)
+		goto out;
+
+	pr_info("Successfully initialized TDX module\n");
+	tdx_module_state = TDX_MODULE_INITIALIZED;
+
+out:
+	vmxoff_err = seam_vmxoff_on_each_cpu();
+	if (vmxoff_err) {
+		pr_info("Failed to VMXOFF.\n");
+		if (!ret)
+			ret = vmxoff_err;
+	}
+out_err:
+	if (ret) {
+		pr_info("Failed to initialize TDX module %d\n", ret);
+		tdx_module_state = TDX_MODULE_ERROR;
+	}
+	if (tdx_module_state == TDX_MODULE_INITIALIZED) {
+		int cpu;
+
+		setup_force_cpu_cap(X86_FEATURE_TDX);
+		for_each_online_cpu(cpu)
+			set_cpu_cap(&cpu_data(cpu), X86_FEATURE_TDX);
+	}
+	cpus_read_unlock();
+
+	seam_free_vmcs_tmp_set();
+	kfree(tdmr_info);
+	kfree(tdx_cmrs);
+	cleanup_subtype_tdx_memory();
+
+	return ret;
 }
+/*
+ * subsys_initcall_sync() is chosen to satisfy the following conditions.
+ * - After P-SEAMLDR is loaded.
+ * - After the TDX module is loaded.
+ * - After iomem_resouce is populated with System RAM including regions
+ *   specified by memmap=nn[KMG]!ss[KMG], which is done by
+ *   e820_reserve_resources() called by setup_arch().  Because
+ *   tdx_construct_tdmr() walks iomem resources looking for legacy pmem region.
+ * - After build_sysmem_tdx_memory() by early_initcall().
+ * - After reserved memory region is polulated in iomem_resource by
+ *   e820__reserve_resources_late(), which is called by
+ *   subsys_initcall(pci_subsys_init).
+ * - After numa node is initialized by pgdata_init() and alloc_contig_pages() is
+ *   available.
+ * - Before kvm_intel.  module_init() is mapped to device_initcall() when
+ *   it's built into the kernel.
+ */
 subsys_initcall_sync(tdx_late_init);
-- 
2.31.1

