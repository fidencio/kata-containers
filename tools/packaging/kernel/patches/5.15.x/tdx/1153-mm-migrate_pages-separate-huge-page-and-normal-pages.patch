From a7ce326386e4b4cded11733223f4e476e2cd0829 Mon Sep 17 00:00:00 2001
From: Huang Ying <ying.huang@intel.com>
Date: Mon, 16 Aug 2021 10:29:19 +0800
Subject: [PATCH 1153/1418] mm/migrate_pages: separate huge page and normal
 pages migration

This is a preparation patch to batch the page unmapping and moving
for the normal pages (including THP).  Based on that we can batch the
TLB shootdown during the page migration and use some hardware
accelerator for the page copying.

In this patch the huge page (PageHuge()) and normal page migration is
separated in migrate_pages() to make it easy to change the normal page
migration implementation.

Signed-off-by: "Huang, Ying" <ying.huang@intel.com>
---
 mm/migrate.c | 69 +++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 57 insertions(+), 12 deletions(-)

diff --git a/mm/migrate.c b/mm/migrate.c
index 9aa4ef8e701c..84965e55a40b 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -1390,6 +1390,57 @@ int migrate_pages(struct list_head *from, new_page_t get_new_page,
 	if (!swapwrite)
 		current->flags |= PF_SWAPWRITE;
 
+	for (pass = 0; pass < 10 && (retry || thp_retry); pass++) {
+		retry = 0;
+		thp_retry = 0;
+
+		list_for_each_entry_safe(page, page2, from, lru) {
+			cond_resched();
+
+			if (!PageHuge(page))
+				continue;
+
+			rc = unmap_and_move_huge_page(get_new_page,
+					put_new_page, private, page,
+					pass > 2, mode, reason,
+					&ret_pages);
+			/*
+			 * The rules are:
+			 *	Success: hugetlb page will be put back
+			 *	-EAGAIN: stay on the from list
+			 *	-ENOMEM: stay on the from list
+			 *	Other errno: put on ret_pages list then splice to
+			 *		     from list
+			 */
+			switch(rc) {
+			case -ENOSYS:
+				/* Hugetlb migration is unsupported */
+				nr_failed++;
+				break;
+			case -ENOMEM:
+				nr_failed++;
+				goto out;
+			case -EAGAIN:
+				retry++;
+				break;
+			case MIGRATEPAGE_SUCCESS:
+				nr_succeeded++;
+				break;
+			default:
+				/*
+				 * Permanent failure (-EBUSY, etc.):
+				 * unlike -EAGAIN case, the failed page is
+				 * removed from migration page list and not
+				 * retried in the next outer loop.
+				 */
+				nr_failed++;
+				break;
+			}
+		}
+	}
+	nr_failed += retry;
+	retry = 1;
+	thp_retry = 1;
 	for (pass = 0; pass < 10 && (retry || thp_retry); pass++) {
 		retry = 0;
 		thp_retry = 0;
@@ -1406,18 +1457,14 @@ int migrate_pages(struct list_head *from, new_page_t get_new_page,
 			cond_resched();
 
 			if (PageHuge(page))
-				rc = unmap_and_move_huge_page(get_new_page,
-						put_new_page, private, page,
-						pass > 2, mode, reason,
-						&ret_pages);
-			else
-				rc = unmap_and_move(get_new_page, put_new_page,
-						private, page, pass > 2, mode,
-						reason, &ret_pages);
+				continue;
+
+			rc = unmap_and_move(get_new_page, put_new_page,
+					    private, page, pass > 2, mode,
+					    reason, &ret_pages);
 			/*
 			 * The rules are:
-			 *	Success: non hugetlb page will be freed, hugetlb
-			 *		 page will be put back
+			 *	Success: page will be freed
 			 *	-EAGAIN: stay on the from list
 			 *	-ENOMEM: stay on the from list
 			 *	Other errno: put on ret_pages list then splice to
@@ -1447,8 +1494,6 @@ int migrate_pages(struct list_head *from, new_page_t get_new_page,
 					nr_failed += nr_subpages;
 					break;
 				}
-
-				/* Hugetlb migration is unsupported */
 				nr_failed++;
 				break;
 			case -ENOMEM:
-- 
2.31.1

