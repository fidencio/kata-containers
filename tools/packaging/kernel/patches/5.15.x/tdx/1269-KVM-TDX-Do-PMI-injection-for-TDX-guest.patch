From 2f84e245f6b370e9a545f30d6712864b3088f657 Mon Sep 17 00:00:00 2001
From: Yuan Yao <yuan.yao@intel.com>
Date: Wed, 16 Mar 2022 13:34:51 +0800
Subject: [PATCH 1269/1418] KVM: TDX: Do PMI injection for TDX guest

The APIC_LVTPC is swtiched before and after TDENTER,
in our new handler we inject PMI to guest without checking
the MSR, because it's dedicate vector for guest PMI. All
PMI injection now can be moved to same place based on
this.

Also did small refactor to put all PMU related code
together before and after TDENTER.

Signed-off-by: Yuan Yao <yuan.yao@intel.com>
---
 arch/x86/kvm/vmx/tdx.c | 73 ++++++++++++++++++++++--------------------
 1 file changed, 38 insertions(+), 35 deletions(-)

diff --git a/arch/x86/kvm/vmx/tdx.c b/arch/x86/kvm/vmx/tdx.c
index 1454f998e4de..2b2aca610352 100644
--- a/arch/x86/kvm/vmx/tdx.c
+++ b/arch/x86/kvm/vmx/tdx.c
@@ -931,18 +931,6 @@ static fastpath_t tdx_vcpu_run(struct kvm_vcpu *vcpu)
 		kvm_wait_lapic_expire(vcpu, true);
 	}
 
-	/*
-	 * Always do PMU context switch here because SEAM module
-	 * unconditionally clear MSR_IA32_DS_AREA, otherwise CPU
-	 * may start to write data into DS area immediately after
-	 * SEAMRET to KVM, which cause PANIC with NULL access.
-	 */
-	intel_pmu_save();
-
-	if (!(kvm_tdx->attributes & TDX_TD_ATTRIBUTE_PERFMON) &&
-		td_profile_allowed(kvm_tdx))
-		tdx_switch_perf_msrs(vcpu);
-
 	/*
 	 * limited to debug td only due to now only debug
 	 * td guest need this feature for instructioin
@@ -959,32 +947,30 @@ static fastpath_t tdx_vcpu_run(struct kvm_vcpu *vcpu)
 			tdx_set_interrupt_shadow(vcpu, 0);
 	}
 
-	tdx_vcpu_enter_exit(vcpu, tdx);
-	tdx_user_return_update_cache();
+	/*
+	 * Always do PMU context switch here because SEAM module
+	 * unconditionally clear MSR_IA32_DS_AREA, otherwise CPU
+	 * may start to write data into DS area immediately after
+	 * SEAMRET to KVM, which cause PANIC with NULL access.
+	 */
+	intel_pmu_save();
+
+	if (!(kvm_tdx->attributes & TDX_TD_ATTRIBUTE_PERFMON) &&
+		td_profile_allowed(kvm_tdx))
+		tdx_switch_perf_msrs(vcpu);
 
 	/*
-	 * Restoring PMU must be after DS area because PMU may start to log
-	 * records in DS area.
+	 * This is safe only when host PMU is disabled, e.g.
+	 * the intel_pmu_save() is called before.
 	 */
-	if (kvm_tdx->attributes & TDX_TD_ATTRIBUTE_PERFMON) {
-		/*
-		 * Guest perf counters overflow leads to a PMI configured by
-		 * host VMM into APIC_LVTPC being delivered.  This PMI causes a
-		 * VM exit.  And as host counters are disabled before TDENTER, a
-		 * PMI pending (if mask is set) always means a guest counter
-		 * overflew.
-		 *
-		 * Simply set a flag to guide following NMI handling and unmask
-		 * APIC_LVTPC here as host counters are to be enabled.
-		 * Otherwise, a subsequent host PMI may be masked.
-		 */
-		if (tdx->exit_reason.basic == EXIT_REASON_EXCEPTION_NMI) {
-			if (apic_read(APIC_LVTPC) & APIC_LVT_MASKED) {
-				tdx->guest_pmi_exit = true;
-				apic_write(APIC_LVTPC, APIC_DM_NMI);
-			}
-		}
-	}
+	if (kvm_tdx->attributes & TDX_TD_ATTRIBUTE_PERFMON)
+		apic_write(APIC_LVTPC, TDX_GUEST_PMI_VECTOR);
+
+	tdx_vcpu_enter_exit(vcpu, tdx);
+	tdx_user_return_update_cache();
+
+	if (kvm_tdx->attributes & TDX_TD_ATTRIBUTE_PERFMON)
+		apic_write(APIC_LVTPC, APIC_DM_NMI);
 
 	perf_restore_debug_store();
 	tdx_restore_host_xsave_state(vcpu);
@@ -3273,6 +3259,21 @@ static int tdx_notifier_callback(struct notifier_block *notifier,
 	return ret;
 }
 
+static void tdx_guest_pmi_handler(void)
+{
+	struct kvm_vcpu *vcpu;
+	struct kvm_tdx  *tdx;
+
+	vcpu = kvm_get_running_vcpu();
+
+	WARN_ON(!vcpu || !is_td_vcpu(vcpu));
+
+	tdx = to_kvm_tdx(vcpu->kvm);
+	WARN_ON(!(tdx->attributes & TDX_TD_ATTRIBUTE_PERFMON));
+
+	kvm_make_request(KVM_REQ_PMI, vcpu);
+}
+
 static struct notifier_block tdx_notifier = {
 	.notifier_call = tdx_notifier_callback,
 };
@@ -3280,11 +3281,13 @@ static struct notifier_block tdx_notifier = {
 static int __init tdx_init(void)
 {
 	register_tdx_notifier(&tdx_notifier);
+	kvm_set_tdx_guest_pmi_handler(tdx_guest_pmi_handler);
 	return 0;
 }
 
 static void __exit tdx_exit(void)
 {
+	kvm_set_tdx_guest_pmi_handler(NULL);
 	unregister_tdx_notifier(&tdx_notifier);
 }
 
-- 
2.31.1

