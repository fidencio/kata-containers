From 6932250a8ecffa94ed9814671d110f8a95353ccb Mon Sep 17 00:00:00 2001
From: Isaku Yamahata <isaku.yamahata@intel.com>
Date: Fri, 20 Nov 2020 15:55:05 -0800
Subject: [PATCH 0415/1418] KVM: TDX: support GET_QUOTE,
 SETUP_EVENT_NOTIFY_INTERRUPT tdvmcall

GET_QUOTE, SETUP_EVENT_NOTIFY_INTERRUPT tdvmcall requires user space
handle them instead of kvm kernel module.
Introduce new kvm exit, KVM_EXIT_TDVMCALL, and when GET_QUOTE
and SETUP_EVENT_NOTIFY_INTERRUPT tdvmcall is called by TD guest,
transfer the exection to user space.
TDG_VP_VMCALL_INVALID_OPERAND is set as default return value to
avoid random value. User space should update R10 if necessary.

Signed-off-by: Isaku Yamahata <isaku.yamahata@intel.com>
---
 arch/x86/kvm/vmx/tdx.c | 64 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 64 insertions(+)

diff --git a/arch/x86/kvm/vmx/tdx.c b/arch/x86/kvm/vmx/tdx.c
index 192ec508333c..a63c1e0746e6 100644
--- a/arch/x86/kvm/vmx/tdx.c
+++ b/arch/x86/kvm/vmx/tdx.c
@@ -1005,6 +1005,36 @@ static int tdx_map_gpa(struct kvm_vcpu *vcpu)
 	return 1;
 }
 
+static int tdx_get_quote(struct kvm_vcpu *vcpu)
+{
+	gpa_t gpa = tdvmcall_p1_read(vcpu);
+
+	if (!IS_ALIGNED(gpa, PAGE_SIZE)) {
+		tdvmcall_set_return_code(vcpu, TDG_VP_VMCALL_INVALID_OPERAND);
+		return 1;
+	}
+
+	/*
+	 * Default return value is set as error.  user space would update this
+	 * value
+	 */
+	tdvmcall_set_return_code(vcpu, TDG_VP_VMCALL_TDREPORT_FAILED);
+	vcpu->run->exit_reason = KVM_EXIT_HYPERCALL;
+	vcpu->run->hypercall.nr = TDG_VP_VMCALL_GET_QUOTE;
+	vcpu->run->hypercall.args[0] = gpa;
+	vcpu->run->hypercall.args[1] = 0;
+	vcpu->run->hypercall.args[2] = 0;
+	vcpu->run->hypercall.args[3] = 0;
+	vcpu->run->hypercall.args[4] = 0;
+	vcpu->run->hypercall.args[5] = 0;
+	vcpu->run->hypercall.ret = 0;
+	vcpu->run->hypercall.longmode = 1;
+	vcpu->run->hypercall.pad = 0;
+
+	/* notify userspace to handle the request */
+	return 0;
+}
+
 static int tdx_report_fatal_error(struct kvm_vcpu *vcpu)
 {
 	vcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;
@@ -1013,6 +1043,36 @@ static int tdx_report_fatal_error(struct kvm_vcpu *vcpu)
 	return 0;
 }
 
+static int tdx_setup_event_notify_interrupt(struct kvm_vcpu *vcpu)
+{
+	u64 vector = tdvmcall_p1_read(vcpu);
+
+	if (!(vector >= 32 && vector <= 255)) {
+		tdvmcall_set_return_code(vcpu, TDG_VP_VMCALL_INVALID_OPERAND);
+		return 1;
+	}
+
+	/*
+	 * Default return value is set as error.  user space would update this
+	 * value
+	 */
+	tdvmcall_set_return_code(vcpu, TDG_VP_VMCALL_INVALID_OPERAND);
+	vcpu->run->exit_reason = KVM_EXIT_HYPERCALL;
+	vcpu->run->hypercall.nr = TDG_VP_VMCALL_SETUP_EVENT_NOTIFY_INTERRUPT;
+	vcpu->run->hypercall.args[0] = vector;
+	vcpu->run->hypercall.args[1] = 0;
+	vcpu->run->hypercall.args[2] = 0;
+	vcpu->run->hypercall.args[3] = 0;
+	vcpu->run->hypercall.args[4] = 0;
+	vcpu->run->hypercall.args[5] = 0;
+	vcpu->run->hypercall.ret = 0;
+	vcpu->run->hypercall.longmode = 1;
+	vcpu->run->hypercall.pad = 0;
+
+	/* notify userspace to handle the request */
+	return 0;
+}
+
 static int handle_tdvmcall(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_tdx *tdx = to_tdx(vcpu);
@@ -1045,8 +1105,12 @@ static int handle_tdvmcall(struct kvm_vcpu *vcpu)
 		return tdx_emulate_mmio(vcpu);
 	case TDG_VP_VMCALL_MAP_GPA:
 		return tdx_map_gpa(vcpu);
+	case TDG_VP_VMCALL_GET_QUOTE:
+		return tdx_get_quote(vcpu);
 	case TDG_VP_VMCALL_REPORT_FATAL_ERROR:
 		return tdx_report_fatal_error(vcpu);
+	case TDG_VP_VMCALL_SETUP_EVENT_NOTIFY_INTERRUPT:
+		return tdx_setup_event_notify_interrupt(vcpu);
 	default:
 		break;
 	}
-- 
2.31.1

