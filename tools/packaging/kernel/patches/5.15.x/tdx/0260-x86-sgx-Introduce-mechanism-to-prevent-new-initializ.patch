From bdafc3589301569fe959c78e6a7547114f325807 Mon Sep 17 00:00:00 2001
From: Cathy Zhang <cathy.zhang@intel.com>
Date: Tue, 8 Jun 2021 14:32:30 +0800
Subject: [PATCH 0260/1418] x86/sgx: Introduce mechanism to prevent new
 initializations of EPC pages

== Background ==

EUPDATESVN is a new SGX instruction which allows enclave attestation
to include information about updated microcode without a reboot.

The SGX hardware maintains metadata for each enclave page to help
enforce its security guarantees. This includes things like a record
of the enclave to which the page belongs and the type of the page:
SGX metadata like "VA" or "SECS" pages, or regular enclave pages
like those that store user data.

Before an EUPDATESVN operation can be successful, all SGX memory (aka.
EPC) must be marked as "unused" in the SGX hardware metadata (aka,
EPCM). The SGX microcode now maintains a reference count of pages
which are unused to aid in determining when all pages reach the
"unused" state.

Both bare-metal and KVM guest EPC must be made unused. To increase
the chance of a successful EUPDATESVN, the kernel prevents existing
enclaves from creating new, valid pages and prevents new enclave
creation (creating an enclave involves initializing a "SECS" page).

The entire EUPDATESVN process is very slow since it potentially
affects gigabytes of enclave memory. It can potentially take seconds
or minutes to complete. Userspace may encounter -EBUSY errors during
the update and is expected to retry.

== Patch contents ==

Introduce mechanism to prevent new initializations of EPC pages.

Use a flag to indicate when SGX EPC pages are "locked", which means
it's not allowed to allocate new EPC page for use. Check it in all
paths that can initialize an EPC page. Use SRCU to ensure that the
flag is visible across the system before proceeding with an update.

Add checks to all sites that call SGX instructions that can transition
pages from unused to initialized to ensure that the SRCU lock is held.

Signed-off-by: Cathy Zhang <cathy.zhang@intel.com>
---
 arch/x86/include/asm/sgx.h      |  8 ++++++
 arch/x86/kernel/cpu/sgx/encl.c  | 28 ++++++++++++++++---
 arch/x86/kernel/cpu/sgx/encls.h |  8 ++++++
 arch/x86/kernel/cpu/sgx/ioctl.c | 48 ++++++++++++++++++++++++---------
 arch/x86/kernel/cpu/sgx/main.c  | 28 +++++++++++++++++++
 arch/x86/kernel/cpu/sgx/sgx.h   |  3 +++
 arch/x86/kernel/cpu/sgx/virt.c  | 20 ++++++++++++++
 7 files changed, 127 insertions(+), 16 deletions(-)

diff --git a/arch/x86/include/asm/sgx.h b/arch/x86/include/asm/sgx.h
index 05f3e21f01a7..13a142b9bcde 100644
--- a/arch/x86/include/asm/sgx.h
+++ b/arch/x86/include/asm/sgx.h
@@ -375,4 +375,12 @@ int sgx_virt_einit(void __user *sigstruct, void __user *token,
 int sgx_set_attribute(unsigned long *allowed_attributes,
 		      unsigned int attribute_fd);
 
+#ifdef CONFIG_X86_SGX
+void sgx_lock_epc(void);
+void sgx_unlock_epc(void);
+#else
+static inline void sgx_lock_epc(void) { }
+static inline void sgx_unlock_epc(void) { }
+#endif
+
 #endif /* _ASM_X86_SGX_H */
diff --git a/arch/x86/kernel/cpu/sgx/encl.c b/arch/x86/kernel/cpu/sgx/encl.c
index 001808e3901c..9cc6dc2e67c3 100644
--- a/arch/x86/kernel/cpu/sgx/encl.c
+++ b/arch/x86/kernel/cpu/sgx/encl.c
@@ -70,16 +70,24 @@ static struct sgx_epc_page *sgx_encl_eldu(struct sgx_encl_page *encl_page,
 	unsigned long va_offset = encl_page->desc & SGX_ENCL_PAGE_VA_OFFSET_MASK;
 	struct sgx_encl *encl = encl_page->encl;
 	struct sgx_epc_page *epc_page;
+	int srcu_idx;
 	int ret;
 
+	srcu_idx = srcu_read_lock(&sgx_lock_epc_srcu);
+	if (sgx_epc_is_locked()) {
+		epc_page = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
 	epc_page = sgx_alloc_epc_page(encl_page, false);
 	if (IS_ERR(epc_page))
-		return epc_page;
+		goto out;
 
 	ret = __sgx_encl_eldu(encl_page, epc_page, secs_page);
 	if (ret) {
 		sgx_encl_free_epc_page(epc_page);
-		return ERR_PTR(ret);
+		epc_page = ERR_PTR(ret);
+		goto out;
 	}
 
 	sgx_free_va_slot(encl_page->va_page, va_offset);
@@ -87,6 +95,8 @@ static struct sgx_epc_page *sgx_encl_eldu(struct sgx_encl_page *encl_page,
 	encl_page->desc &= ~SGX_ENCL_PAGE_VA_OFFSET_MASK;
 	encl_page->epc_page = epc_page;
 
+out:
+	srcu_read_unlock(&sgx_lock_epc_srcu, srcu_idx);
 	return epc_page;
 }
 
@@ -677,19 +687,29 @@ int sgx_encl_test_and_clear_young(struct mm_struct *mm,
 struct sgx_epc_page *sgx_alloc_va_page(void)
 {
 	struct sgx_epc_page *epc_page;
+	int srcu_idx;
 	int ret;
 
+	srcu_idx = srcu_read_lock(&sgx_lock_epc_srcu);
+	if (sgx_epc_is_locked()) {
+		epc_page = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
 	epc_page = sgx_alloc_epc_page(NULL, true);
 	if (IS_ERR(epc_page))
-		return ERR_CAST(epc_page);
+		goto out;
 
 	ret = __epa(sgx_get_epc_virt_addr(epc_page));
 	if (ret) {
 		WARN_ONCE(1, "EPA returned %d (0x%x)", ret, ret);
 		sgx_encl_free_epc_page(epc_page);
-		return ERR_PTR(-EFAULT);
+		epc_page = ERR_PTR(-EFAULT);
+		goto out;
 	}
 
+out:
+	srcu_read_unlock(&sgx_lock_epc_srcu, srcu_idx);
 	return epc_page;
 }
 
diff --git a/arch/x86/kernel/cpu/sgx/encls.h b/arch/x86/kernel/cpu/sgx/encls.h
index 9b204843b78d..0f37e7617a57 100644
--- a/arch/x86/kernel/cpu/sgx/encls.h
+++ b/arch/x86/kernel/cpu/sgx/encls.h
@@ -164,6 +164,8 @@ static inline bool encls_failed(int ret)
 
 static inline int __ecreate(struct sgx_pageinfo *pginfo, void *secs)
 {
+	lockdep_assert_held(&sgx_lock_epc_srcu);
+
 	return __encls_2(ECREATE, pginfo, secs);
 }
 
@@ -174,6 +176,8 @@ static inline int __eextend(void *secs, void *addr)
 
 static inline int __eadd(struct sgx_pageinfo *pginfo, void *addr)
 {
+	lockdep_assert_held(&sgx_lock_epc_srcu);
+
 	return __encls_2(EADD, pginfo, addr);
 }
 
@@ -205,6 +209,8 @@ static inline int __etrack(void *addr)
 static inline int __eldu(struct sgx_pageinfo *pginfo, void *addr,
 			 void *va)
 {
+	lockdep_assert_held(&sgx_lock_epc_srcu);
+
 	return __encls_ret_3(ELDU, pginfo, addr, va);
 }
 
@@ -217,6 +223,8 @@ static inline int __epa(void *addr)
 {
 	unsigned long rbx = SGX_PAGE_TYPE_VA;
 
+	lockdep_assert_held(&sgx_lock_epc_srcu);
+
 	return __encls_2(EPA, rbx, addr);
 }
 
diff --git a/arch/x86/kernel/cpu/sgx/ioctl.c b/arch/x86/kernel/cpu/sgx/ioctl.c
index 83df20e3e633..3289e07f86cc 100644
--- a/arch/x86/kernel/cpu/sgx/ioctl.c
+++ b/arch/x86/kernel/cpu/sgx/ioctl.c
@@ -30,6 +30,7 @@ static struct sgx_va_page *sgx_encl_grow(struct sgx_encl *encl)
 		if (!va_page)
 			return ERR_PTR(-ENOMEM);
 
+		INIT_LIST_HEAD(&va_page->list);
 		va_page->epc_page = sgx_alloc_va_page();
 		if (IS_ERR(va_page->epc_page)) {
 			err = ERR_CAST(va_page->epc_page);
@@ -49,7 +50,8 @@ static void sgx_encl_shrink(struct sgx_encl *encl, struct sgx_va_page *va_page)
 
 	if (va_page) {
 		sgx_encl_free_epc_page(va_page->epc_page);
-		list_del(&va_page->list);
+		if (!list_empty(&va_page->list))
+			list_del(&va_page->list);
 		kfree(va_page);
 	}
 }
@@ -63,6 +65,7 @@ static int sgx_encl_create(struct sgx_encl *encl, struct sgx_secs *secs)
 	unsigned long encl_size;
 	struct file *backing;
 	long ret;
+	int srcu_idx;
 
 	va_page = sgx_encl_grow(encl);
 	if (IS_ERR(va_page))
@@ -83,6 +86,12 @@ static int sgx_encl_create(struct sgx_encl *encl, struct sgx_secs *secs)
 
 	encl->backing = backing;
 
+	srcu_idx = srcu_read_lock(&sgx_lock_epc_srcu);
+	if (sgx_epc_is_locked()) {
+		ret = -EBUSY;
+		goto err_out_backing;
+	}
+
 	secs_epc = sgx_alloc_epc_page(&encl->secs, true);
 	if (IS_ERR(secs_epc)) {
 		ret = PTR_ERR(secs_epc);
@@ -115,6 +124,8 @@ static int sgx_encl_create(struct sgx_encl *encl, struct sgx_secs *secs)
 	/* Set only after completion, as encl->lock has not been taken. */
 	set_bit(SGX_ENCL_CREATED, &encl->flags);
 
+	srcu_read_unlock(&sgx_lock_epc_srcu, srcu_idx);
+
 	return 0;
 
 err_out:
@@ -122,6 +133,7 @@ static int sgx_encl_create(struct sgx_encl *encl, struct sgx_secs *secs)
 	encl->secs.epc_page = NULL;
 
 err_out_backing:
+	srcu_read_unlock(&sgx_lock_epc_srcu, srcu_idx);
 	fput(encl->backing);
 	encl->backing = NULL;
 
@@ -295,20 +307,27 @@ static int sgx_encl_add_page(struct sgx_encl *encl, unsigned long src,
 	struct sgx_epc_page *epc_page;
 	struct sgx_va_page *va_page;
 	int ret;
+	int srcu_idx;
+
+	va_page = sgx_encl_grow(encl);
+	if (IS_ERR(va_page))
+		return PTR_ERR(va_page);
 
 	encl_page = sgx_encl_page_alloc(encl, offset, secinfo->flags);
-	if (IS_ERR(encl_page))
-		return PTR_ERR(encl_page);
+	if (IS_ERR(encl_page)) {
+		ret = PTR_ERR(encl_page);
+		goto err_out_shrink;
+	}
 
-	epc_page = sgx_alloc_epc_page(encl_page, true);
-	if (IS_ERR(epc_page)) {
-		kfree(encl_page);
-		return PTR_ERR(epc_page);
+	srcu_idx = srcu_read_lock(&sgx_lock_epc_srcu);
+	if (sgx_epc_is_locked()) {
+		ret = -EBUSY;
+		goto err_out_free;
 	}
 
-	va_page = sgx_encl_grow(encl);
-	if (IS_ERR(va_page)) {
-		ret = PTR_ERR(va_page);
+	epc_page = sgx_alloc_epc_page(encl_page, true);
+	if (IS_ERR(epc_page)) {
+		ret = PTR_ERR(epc_page);
 		goto err_out_free;
 	}
 
@@ -353,22 +372,27 @@ static int sgx_encl_add_page(struct sgx_encl *encl, unsigned long src,
 	}
 
 	sgx_mark_page_reclaimable(encl_page->epc_page);
+
 	mutex_unlock(&encl->lock);
 	mmap_read_unlock(current->mm);
+	srcu_read_unlock(&sgx_lock_epc_srcu, srcu_idx);
 	return ret;
 
 err_out:
 	xa_erase(&encl->page_array, PFN_DOWN(encl_page->desc));
 
 err_out_unlock:
-	sgx_encl_shrink(encl, va_page);
 	mutex_unlock(&encl->lock);
 	mmap_read_unlock(current->mm);
+	sgx_encl_free_epc_page(epc_page);
 
 err_out_free:
-	sgx_encl_free_epc_page(epc_page);
+	srcu_read_unlock(&sgx_lock_epc_srcu, srcu_idx);
 	kfree(encl_page);
 
+err_out_shrink:
+	sgx_encl_shrink(encl, va_page);
+
 	return ret;
 }
 
diff --git a/arch/x86/kernel/cpu/sgx/main.c b/arch/x86/kernel/cpu/sgx/main.c
index 63d3de02bbcc..16e4e557355e 100644
--- a/arch/x86/kernel/cpu/sgx/main.c
+++ b/arch/x86/kernel/cpu/sgx/main.c
@@ -20,6 +20,17 @@ struct sgx_epc_section sgx_epc_sections[SGX_MAX_EPC_SECTIONS];
 static int sgx_nr_epc_sections;
 static struct task_struct *ksgxd_tsk;
 static DECLARE_WAIT_QUEUE_HEAD(ksgxd_waitq);
+/*
+ * The flags prevents new from using SGX for
+ * things like EADD.
+ */
+static bool __rcu sgx_epc_locked;
+/*
+ * SRCU ensures that old users that might not
+ * have noticed the flag have gone away before
+ * proceeding with an SVN update.
+ */
+DEFINE_SRCU(sgx_lock_epc_srcu);
 
 /*
  * These variables are part of the state of the reclaimer, and must be accessed
@@ -841,3 +852,20 @@ static int __init sgx_init(void)
 }
 
 device_initcall(sgx_init);
+
+void sgx_lock_epc(void)
+{
+	sgx_epc_locked = true;
+	synchronize_srcu(&sgx_lock_epc_srcu);
+}
+
+void sgx_unlock_epc(void)
+{
+	sgx_epc_locked = false;
+	synchronize_srcu(&sgx_lock_epc_srcu);
+}
+
+bool sgx_epc_is_locked(void)
+{
+	return sgx_epc_locked;
+}
diff --git a/arch/x86/kernel/cpu/sgx/sgx.h b/arch/x86/kernel/cpu/sgx/sgx.h
index 4628acec0009..76064254a35b 100644
--- a/arch/x86/kernel/cpu/sgx/sgx.h
+++ b/arch/x86/kernel/cpu/sgx/sgx.h
@@ -95,4 +95,7 @@ static inline int __init sgx_vepc_init(void)
 
 void sgx_update_lepubkeyhash(u64 *lepubkeyhash);
 
+extern struct srcu_struct sgx_lock_epc_srcu;
+bool sgx_epc_is_locked(void);
+
 #endif /* _X86_SGX_H */
diff --git a/arch/x86/kernel/cpu/sgx/virt.c b/arch/x86/kernel/cpu/sgx/virt.c
index 6a77a14eee38..d6ae86a98743 100644
--- a/arch/x86/kernel/cpu/sgx/virt.c
+++ b/arch/x86/kernel/cpu/sgx/virt.c
@@ -76,9 +76,20 @@ static vm_fault_t sgx_vepc_fault(struct vm_fault *vmf)
 	struct vm_area_struct *vma = vmf->vma;
 	struct sgx_vepc *vepc = vma->vm_private_data;
 	int ret;
+	int srcu_idx;
 
 	mutex_lock(&vepc->lock);
+	srcu_idx = srcu_read_lock(&sgx_lock_epc_srcu);
+
+	if (sgx_epc_is_locked()) {
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+
 	ret = __sgx_vepc_fault(vepc, vma, vmf->address);
+
+out_unlock:
+	srcu_read_unlock(&sgx_lock_epc_srcu, srcu_idx);
 	mutex_unlock(&vepc->lock);
 
 	if (!ret)
@@ -332,6 +343,7 @@ int sgx_virt_ecreate(struct sgx_pageinfo *pageinfo, void __user *secs,
 		     int *trapnr)
 {
 	int ret;
+	int srcu_idx;
 
 	/*
 	 * @secs is an untrusted, userspace-provided address.  It comes from
@@ -347,6 +359,12 @@ int sgx_virt_ecreate(struct sgx_pageinfo *pageinfo, void __user *secs,
 	if (WARN_ON_ONCE(!access_ok(secs, PAGE_SIZE)))
 		return -EINVAL;
 
+	srcu_idx = srcu_read_lock(&sgx_lock_epc_srcu);
+	if (sgx_epc_is_locked()) {
+		srcu_read_unlock(&sgx_lock_epc_srcu, srcu_idx);
+		return -EBUSY;
+	}
+
 	__uaccess_begin();
 	ret = __ecreate(pageinfo, (void *)secs);
 	__uaccess_end();
@@ -356,6 +374,8 @@ int sgx_virt_ecreate(struct sgx_pageinfo *pageinfo, void __user *secs,
 		return -EFAULT;
 	}
 
+	srcu_read_unlock(&sgx_lock_epc_srcu, srcu_idx);
+
 	/* ECREATE doesn't return an error code, it faults or succeeds. */
 	WARN_ON_ONCE(ret);
 	return 0;
-- 
2.31.1

