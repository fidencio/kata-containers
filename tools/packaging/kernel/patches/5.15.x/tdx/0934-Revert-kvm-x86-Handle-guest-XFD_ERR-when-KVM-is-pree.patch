From b8c96729ce452ee382995d9c83b0a253181b3e07 Mon Sep 17 00:00:00 2001
From: Yang Zhong <yang.zhong@intel.com>
Date: Mon, 24 Jan 2022 18:02:40 -0800
Subject: [PATCH 0934/1418] Revert "kvm: x86: Handle guest XFD_ERR when KVM is
 preempted"

This reverts commit 4f6120bd772330469c812d5a49489e1225c82b21.
---
 arch/x86/kvm/vmx/vmx.c |  3 ---
 arch/x86/kvm/x86.c     | 30 ------------------------------
 arch/x86/kvm/x86.h     |  1 -
 3 files changed, 34 deletions(-)

diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index ae7223efdc68..0d951d300daf 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -1235,9 +1235,6 @@ static void vmx_prepare_switch_to_host(struct vcpu_vmx *vmx)
 	invalidate_tss_limit();
 #ifdef CONFIG_X86_64
 	wrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);
-
-	if (vmx->vcpu.preempted)
-		kvm_save_guest_xfd_err(&vmx->vcpu);
 #endif
 	load_fixmap_gdt(raw_smp_processor_id());
 	vmx->guest_state_loaded = false;
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 9cf2828a3d3e..e56cbabb8616 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -989,34 +989,6 @@ void kvm_load_host_xsave_state(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_load_host_xsave_state);
 
-void kvm_save_guest_xfd_err(struct kvm_vcpu *vcpu)
-{
-	struct fpu_guest *guest_fpu = &vcpu->arch.guest_fpu;
-
-	if (guest_cpuid_has(vcpu, X86_FEATURE_XFD)) {
-		/* Only guest XFD_ERR need be saved. */
-		if (!current->thread.fpu.fpstate->is_guest)
-			return;
-		/* Already saved before. */
-		if (guest_fpu->xfd_err_dirty)
-			return;
-
-		rdmsrl(MSR_IA32_XFD_ERR, guest_fpu->xfd_err);
-		if (guest_fpu->xfd_err)
-			guest_fpu->xfd_err_dirty = true;
-	}
-}
-EXPORT_SYMBOL_GPL(kvm_save_guest_xfd_err);
-
-static void kvm_restore_xfd_err(struct kvm_vcpu *vcpu)
-{
-	if (vcpu->arch.guest_fpu.xfd_err_dirty && vcpu->arch.guest_fpu.xfd_err) {
-		wrmsrl(MSR_IA32_XFD_ERR, vcpu->arch.guest_fpu.xfd_err);
-		vcpu->arch.guest_fpu.xfd_err_dirty = false;
-		vcpu->arch.guest_fpu.xfd_err = 0;
-	}
-}
-
 /*
  * Return dynamic feature bitmap that xcr0[i]=1 && xfd[i]=0
  */
@@ -9918,8 +9890,6 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 		set_debugreg(0, 7);
 	}
 
-	kvm_restore_xfd_err(vcpu);
-
 	for (;;) {
 		exit_fastpath = static_call(kvm_x86_run)(vcpu);
 		if (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST))
diff --git a/arch/x86/kvm/x86.h b/arch/x86/kvm/x86.h
index a41d560df29d..8fc6f84ec2ce 100644
--- a/arch/x86/kvm/x86.h
+++ b/arch/x86/kvm/x86.h
@@ -451,7 +451,6 @@ static inline bool kvm_pkrs_valid(u64 data)
 void kvm_load_guest_xsave_state(struct kvm_vcpu *vcpu);
 void kvm_load_host_xsave_state(struct kvm_vcpu *vcpu);
 bool kvm_guest_realloc_fpstate(struct kvm_vcpu *vcpu, u64 new_xfd);
-void kvm_save_guest_xfd_err(struct kvm_vcpu *vcpu);
 int kvm_spec_ctrl_test_value(u64 value);
 bool kvm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4);
 int kvm_handle_memory_failure(struct kvm_vcpu *vcpu, int r,
-- 
2.31.1

