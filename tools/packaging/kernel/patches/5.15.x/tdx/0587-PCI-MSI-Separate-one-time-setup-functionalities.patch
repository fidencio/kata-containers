From f0d9d29a525f55883362e2fa83cfa33cf49bdd81 Mon Sep 17 00:00:00 2001
From: Megha Dey <megha.dey@intel.com>
Date: Mon, 18 Oct 2021 12:50:04 -0700
Subject: [PATCH 0587/1418] PCI/MSI: Separate one time setup functionalities

This is a preparatory patch to enable dynamic allocation of MSI-X
interrupts.

There are some functions which needs to be performed only once even
after enabling dynamic allocation of MSI-X vectors. These include
setting up the
1. device MSI-X table
2. sysfs folder for the MSI/MSI-X interrupts

Use the dev->msix_enabled flag to ensure that these structures are setup
only once.

Also, msix_capability_init() sets up the
1. device MSI-X table (called once per device)
2. MSI-X vectors requested (can be called multiple times once dynamic
MSI-X is enabled)
Separate out these 2 functionalities.

No functional change.

Signed-off-by: Megha Dey <megha.dey@intel.com>
---
 drivers/pci/msi.c | 72 ++++++++++++++++++++++++++++++-----------------
 1 file changed, 46 insertions(+), 26 deletions(-)

diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c
index 99e483838d8a..069d9a05775f 100644
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -683,20 +683,12 @@ static void msix_mask_all(void __iomem *base, int tsize)
 /**
  * msix_capability_init - configure device's MSI-X capability
  * @dev: pointer to the pci_dev data structure of MSI-X device function
- * @entries: pointer to an array of struct msix_entry entries
- * @nvec: number of @entries
- * @affd: Optional pointer to enable automatic affinity assignment
- *
- * Setup the MSI-X capability structure of device function with a
- * single MSI-X IRQ. A return of zero indicates the successful setup of
- * requested MSI-X entries with allocated IRQs or non-zero for otherwise.
+ * Setup the MSI-X capability structure of device function
  **/
-static int msix_capability_init(struct pci_dev *dev, struct msix_entry *entries,
-				int nvec, struct irq_affinity *affd)
+static int msix_capability_init(struct pci_dev *dev)
 {
-	const struct attribute_group **groups;
-	int ret, tsize;
 	u16 control;
+	int tsize;
 
 	/*
 	 * Some devices require MSI-X to be enabled before the MSI-X
@@ -711,12 +703,29 @@ static int msix_capability_init(struct pci_dev *dev, struct msix_entry *entries,
 	tsize = msix_table_size(control);
 	dev->msix_table_base = msix_map_region(dev, tsize);
 	if (!dev->msix_table_base) {
-		ret = -ENOMEM;
-		goto out_disable;
+		pci_msix_clear_and_set_ctrl(dev, PCI_MSIX_FLAGS_ENABLE, 0);
+		return -ENOMEM;
 	}
 
 	/* Ensure that all table entries are masked. */
 	msix_mask_all(dev->msix_table_base, tsize);
+	return 0;
+}
+
+/**
+ * msix_setup_irqs - setup requested number of MSI-X entries
+ * @dev:	pointer to the pci_dev data structure of MSI-X device function
+ * @entries:	pointer to an array of struct msix_entry entries
+ * @nvec:	number of @entries
+ * @affd:	Optional pointer to enable automatic affinity assignment
+ *
+ * A return of zero indicates the successful setup of the requested IRQs
+ * or non-zero for otherwise.
+ **/
+static int msix_setup_irqs(struct pci_dev *dev, struct msix_entry *entries,
+			   int nvec, struct irq_affinity *affd)
+{
+	int ret = 0;
 
 	ret = msix_setup_entries(dev, entries, nvec, affd);
 	if (ret)
@@ -733,20 +742,25 @@ static int msix_capability_init(struct pci_dev *dev, struct msix_entry *entries,
 
 	msix_update_entries(dev, entries);
 
-	groups = msi_populate_sysfs(&dev->dev);
-	if (IS_ERR(groups)) {
-		ret = PTR_ERR(groups);
-		goto out_free;
-	}
+	if (!dev->msix_enabled) {
+		const struct attribute_group **groups;
 
-	dev->msi_irq_groups = groups;
+		groups = msi_populate_sysfs(&dev->dev);
+		if (IS_ERR(groups)) {
+			ret = PTR_ERR(groups);
+			goto out_free;
+		}
 
-	/* Set MSI-X enabled bits and unmask the function */
-	pci_intx_for_msi(dev, 0);
-	dev->msix_enabled = 1;
-	pci_msix_clear_and_set_ctrl(dev, PCI_MSIX_FLAGS_MASKALL, 0);
+		dev->msi_irq_groups = groups;
+
+		/* Set MSI-X enabled bits and unmask the function */
+		pci_intx_for_msi(dev, 0);
+		dev->msix_enabled = 1;
+		pci_msix_clear_and_set_ctrl(dev, PCI_MSIX_FLAGS_MASKALL, 0);
+
+		pcibios_free_irq(dev);
+	}
 
-	pcibios_free_irq(dev);
 	return 0;
 
 out_avail:
@@ -770,7 +784,8 @@ static int msix_capability_init(struct pci_dev *dev, struct msix_entry *entries,
 	free_msi_irqs(dev);
 
 out_disable:
-	pci_msix_clear_and_set_ctrl(dev, PCI_MSIX_FLAGS_ENABLE, 0);
+	if (!dev->msix_enabled)
+		pci_msix_clear_and_set_ctrl(dev, PCI_MSIX_FLAGS_ENABLE, 0);
 
 	return ret;
 }
@@ -933,7 +948,12 @@ static int __pci_enable_msix(struct pci_dev *dev, struct msix_entry *entries,
 		pci_info(dev, "can't enable MSI-X (MSI IRQ already assigned)\n");
 		return -EINVAL;
 	}
-	return msix_capability_init(dev, entries, nvec, affd);
+
+	if (!dev->msix_enabled)
+		if (msix_capability_init(dev))
+			return -ENOMEM;
+
+	return msix_setup_irqs(dev, entries, nvec, affd);
 }
 
 static void pci_msix_shutdown(struct pci_dev *dev)
-- 
2.31.1

