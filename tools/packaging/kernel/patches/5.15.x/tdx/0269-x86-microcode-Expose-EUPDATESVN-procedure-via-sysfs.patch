From aa2fb37c5a5e79582eb97df20051ff95e6ca3da4 Mon Sep 17 00:00:00 2001
From: Cathy Zhang <cathy.zhang@intel.com>
Date: Wed, 28 Apr 2021 02:42:39 +0800
Subject: [PATCH 0269/1418] x86/microcode: Expose EUPDATESVN procedure via
 sysfs

EUPDATESVN is the SGX instruction which allows enclave attestation
to include information about updated microcode without a reboot.

Microcode updates which affect SGX require two phases:

1. Do the main microcode update
2. Make the new CPUSVN available for enclave attestation via
   EUPDATESVN.

Before a EUPDATESVN can succeed, all enclave pages (EPC) must be
marked as unused in the SGX metadata (EPCM). This operation destroys
all preexisting SGX enclave data and metadata. This is by design and
mitigates the impact of vulnerabilities that may have compromised
enclaves or the SGX hardware itself prior to the update.

Signed-off-by: Cathy Zhang <cathy.zhang@intel.com>
---
 arch/x86/include/asm/microcode_intel.h |  2 +
 arch/x86/include/asm/sgx.h             |  2 +
 arch/x86/kernel/cpu/microcode/core.c   | 52 ++++++++++++++++++++++++++
 arch/x86/kernel/cpu/microcode/intel.c  | 24 ++++++++++++
 4 files changed, 80 insertions(+)

diff --git a/arch/x86/include/asm/microcode_intel.h b/arch/x86/include/asm/microcode_intel.h
index d85a07d7154f..a342234a0a5b 100644
--- a/arch/x86/include/asm/microcode_intel.h
+++ b/arch/x86/include/asm/microcode_intel.h
@@ -74,12 +74,14 @@ extern void load_ucode_intel_ap(void);
 extern void show_ucode_info_early(void);
 extern int __init save_microcode_in_initrd_intel(void);
 void reload_ucode_intel(void);
+int update_cpusvn_intel(void);
 #else
 static inline __init void load_ucode_intel_bsp(void) {}
 static inline void load_ucode_intel_ap(void) {}
 static inline void show_ucode_info_early(void) {}
 static inline int __init save_microcode_in_initrd_intel(void) { return -EINVAL; }
 static inline void reload_ucode_intel(void) {}
+static inline int update_cpusvn_intel(void) { return -1; }
 #endif
 
 #endif /* _ASM_X86_MICROCODE_INTEL_H */
diff --git a/arch/x86/include/asm/sgx.h b/arch/x86/include/asm/sgx.h
index 8efb9508753e..a0d893851066 100644
--- a/arch/x86/include/asm/sgx.h
+++ b/arch/x86/include/asm/sgx.h
@@ -28,6 +28,8 @@
 #define SGX_CPUID_EPC_SECTION	0x1
 /* The bitmask for the EPC section type. */
 #define SGX_CPUID_EPC_MASK	GENMASK(3, 0)
+/* EUPDATESVN presence indication */
+#define SGX_CPUID_EUPDATESVN	BIT(10)
 
 enum sgx_encls_function {
 	ECREATE		= 0x00,
diff --git a/arch/x86/kernel/cpu/microcode/core.c b/arch/x86/kernel/cpu/microcode/core.c
index efb69be41ab1..7efc2b58e5c3 100644
--- a/arch/x86/kernel/cpu/microcode/core.c
+++ b/arch/x86/kernel/cpu/microcode/core.c
@@ -39,6 +39,9 @@
 #include <asm/processor.h>
 #include <asm/cmdline.h>
 #include <asm/setup.h>
+#include <asm/sgx.h>
+#include <asm/cpu.h>
+#include <asm/cpufeature.h>
 
 #define DRIVER_VERSION	"2.2"
 
@@ -820,6 +823,33 @@ static int mc_cpu_down_prep(unsigned int cpu)
 	return 0;
 }
 
+static ssize_t svnupdate_store(struct device *dev,
+			    struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	unsigned long val;
+	ssize_t ret = 0;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val != 1)
+		return size;
+
+	mutex_lock(&microcode_mutex);
+
+	ret = update_cpusvn_intel();
+
+	mutex_unlock(&microcode_mutex);
+
+	if (ret == 0)
+		ret = size;
+
+	return ret;
+}
+static DEVICE_ATTR_WO(svnupdate);
+
 static struct attribute *cpu_root_microcode_attrs[] = {
 	&dev_attr_reload.attr,
 	NULL
@@ -833,6 +863,7 @@ static const struct attribute_group cpu_root_microcode_group = {
 static int __init microcode_init(void)
 {
 	struct cpuinfo_x86 *c = &boot_cpu_data;
+	unsigned int cpuid_level;
 	int error;
 
 	if (dis_ucode_ldr)
@@ -873,6 +904,27 @@ static int __init microcode_init(void)
 		goto out_driver;
 	}
 
+	/*
+	 * Check CPUID directly. If SGX support bit is on
+	 * in CPUID level 0x00000007:0 (EBX), and EUPDAESVN
+	 * is enabled, allow svnupdate to occur even if
+	 * X86/FEATURE_SGX is clear. Future kexec()'s kernels
+	 * may want to use SGX.
+	 */
+	cpuid_level = cpuid_eax(0);
+	if ((cpuid_level >= 7) &&
+	    (cpuid_ebx(7) & (X86_FEATURE_SGX % 32)) &&
+	    (cpuid_eax(SGX_CPUID) & SGX_CPUID_EUPDATESVN)) {
+		error = sysfs_add_file_to_group(&cpu_subsys.dev_root->kobj,
+						&dev_attr_svnupdate.attr,
+						"microcode");
+
+		if (error) {
+			pr_err("Error creating microcode svnupdate file!\n");
+			goto out_ucode_group;
+		}
+	}
+
 	error = microcode_dev_init();
 	if (error)
 		goto out_ucode_group;
diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c
index 7e8e07bddd5f..58bf4c81867e 100644
--- a/arch/x86/kernel/cpu/microcode/intel.c
+++ b/arch/x86/kernel/cpu/microcode/intel.c
@@ -36,6 +36,7 @@
 #include <asm/tlbflush.h>
 #include <asm/setup.h>
 #include <asm/msr.h>
+#include <asm/sgx.h>
 
 static const char ucode_path[] = "kernel/x86/microcode/GenuineIntel.bin";
 
@@ -1000,3 +1001,26 @@ struct microcode_ops * __init init_intel_microcode(void)
 
 	return &microcode_intel_ops;
 }
+
+int update_cpusvn_intel(void)
+{
+	int ret;
+
+	sgx_lock_epc();
+	ret = sgx_zap_pages();
+	if (!ret)
+		ret = sgx_updatesvn();
+	sgx_unlock_epc();
+
+	if (ret == SGX_NO_UPDATE)
+		ret = 0;
+	else if (ret == SGX_EPC_NOT_READY)
+		ret = -EBUSY;
+	else if (ret > 0)
+		ret = -1;
+
+	if (!ret)
+		pr_info("CPUSVN update is complete\n");
+
+	return ret;
+}
-- 
2.31.1

