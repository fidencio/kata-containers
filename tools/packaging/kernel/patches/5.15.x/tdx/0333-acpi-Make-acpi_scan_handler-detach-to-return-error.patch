From af6fc1b959c85444757e3cea1f77b7341e88e39a Mon Sep 17 00:00:00 2001
From: Isaku Yamahata <isaku.yamahata@intel.com>
Date: Tue, 20 Jul 2021 16:22:48 +1200
Subject: [PATCH 0333/1418] acpi: Make acpi_scan_handler::detach to return
 error

Because TDX(according to TDX module specification 344425-002US) doesn't
support CPU hotplug, physical CPU hot unplug must be disabled when TDX is
enabled.  The acpi_scan_handler.detach method that is called to unplug
devices doesn't return a value.  Make the method return a value to allow
refusing a physical unplug, and make the detach method for the processor
allow this refusal.

Signed-off-by: Isaku Yamahata <isaku.yamahata@intel.com>
---
 drivers/acpi/acpi_cmos_rtc.c   |  3 ++-
 drivers/acpi/acpi_memhotplug.c |  7 ++++---
 drivers/acpi/acpi_processor.c  | 14 ++++++++++----
 drivers/acpi/container.c       |  3 ++-
 drivers/acpi/pci_link.c        |  5 +++--
 drivers/acpi/pci_root.c        |  5 +++--
 drivers/acpi/scan.c            | 31 ++++++++++++++++++++++---------
 include/acpi/acpi_bus.h        |  4 ++--
 8 files changed, 48 insertions(+), 24 deletions(-)

diff --git a/drivers/acpi/acpi_cmos_rtc.c b/drivers/acpi/acpi_cmos_rtc.c
index 4cf4aef7ce0c..015e18e18ea8 100644
--- a/drivers/acpi/acpi_cmos_rtc.c
+++ b/drivers/acpi/acpi_cmos_rtc.c
@@ -68,11 +68,12 @@ static int acpi_install_cmos_rtc_space_handler(struct acpi_device *adev,
 	return 1;
 }
 
-static void acpi_remove_cmos_rtc_space_handler(struct acpi_device *adev)
+static int acpi_remove_cmos_rtc_space_handler(struct acpi_device *adev)
 {
 	if (ACPI_FAILURE(acpi_remove_address_space_handler(adev->handle,
 			ACPI_ADR_SPACE_CMOS, &acpi_cmos_rtc_space_handler)))
 		pr_err("Error removing CMOS-RTC region handler\n");
+	return 0;
 }
 
 static struct acpi_scan_handler cmos_rtc_handler = {
diff --git a/drivers/acpi/acpi_memhotplug.c b/drivers/acpi/acpi_memhotplug.c
index 24f662d8bd39..995264472123 100644
--- a/drivers/acpi/acpi_memhotplug.c
+++ b/drivers/acpi/acpi_memhotplug.c
@@ -31,7 +31,7 @@ static const struct acpi_device_id memory_device_ids[] = {
 
 static int acpi_memory_device_add(struct acpi_device *device,
 				  const struct acpi_device_id *not_used);
-static void acpi_memory_device_remove(struct acpi_device *device);
+static int acpi_memory_device_remove(struct acpi_device *device);
 
 static struct acpi_scan_handler memory_device_handler = {
 	.ids = memory_device_ids,
@@ -327,16 +327,17 @@ static int acpi_memory_device_add(struct acpi_device *device,
 	return 1;
 }
 
-static void acpi_memory_device_remove(struct acpi_device *device)
+static int acpi_memory_device_remove(struct acpi_device *device)
 {
 	struct acpi_memory_device *mem_device;
 
 	if (!device || !acpi_driver_data(device))
-		return;
+		return 0;
 
 	mem_device = acpi_driver_data(device);
 	acpi_memory_remove_memory(mem_device);
 	acpi_memory_device_free(mem_device);
+	return 0;
 }
 
 static bool __initdata acpi_no_memhotplug;
diff --git a/drivers/acpi/acpi_processor.c b/drivers/acpi/acpi_processor.c
index e46efcda77ad..f12616958cf9 100644
--- a/drivers/acpi/acpi_processor.c
+++ b/drivers/acpi/acpi_processor.c
@@ -432,18 +432,23 @@ static int acpi_processor_add(struct acpi_device *device,
 
 #ifdef CONFIG_ACPI_HOTPLUG_CPU
 /* Removal */
-static void acpi_processor_remove(struct acpi_device *device)
+static int acpi_processor_remove(struct acpi_device *device)
 {
 	struct acpi_processor *pr;
+	int result = 0;
 
 	if (!device || !acpi_driver_data(device))
-		return;
+		return -EINVAL;
 
 	pr = acpi_driver_data(device);
-	if (pr->id >= nr_cpu_ids)
+	if (pr->id >= nr_cpu_ids) {
+		result = -EINVAL;
 		goto out;
-	if (!acpi_unmap_cpu_allowed(pr->id))
+	}
+	if (!acpi_unmap_cpu_allowed(pr->id)) {
+		result = -EOPNOTSUPP;
 		goto out;
+	}
 
 	/*
 	 * The only reason why we ever get here is CPU hot-removal.  The CPU is
@@ -475,6 +480,7 @@ static void acpi_processor_remove(struct acpi_device *device)
  out:
 	free_cpumask_var(pr->throttling.shared_cpu_map);
 	kfree(pr);
+	return result;
 }
 #endif /* CONFIG_ACPI_HOTPLUG_CPU */
 
diff --git a/drivers/acpi/container.c b/drivers/acpi/container.c
index ccaa647ac3d4..996f3431ab00 100644
--- a/drivers/acpi/container.c
+++ b/drivers/acpi/container.c
@@ -70,13 +70,14 @@ static int container_device_attach(struct acpi_device *adev,
 	return 1;
 }
 
-static void container_device_detach(struct acpi_device *adev)
+static int container_device_detach(struct acpi_device *adev)
 {
 	struct device *dev = acpi_driver_data(adev);
 
 	adev->driver_data = NULL;
 	if (dev)
 		device_unregister(dev);
+	return 0;
 }
 
 static void container_device_online(struct acpi_device *adev)
diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c
index cb7b900d9466..3630b56c525f 100644
--- a/drivers/acpi/pci_link.c
+++ b/drivers/acpi/pci_link.c
@@ -35,7 +35,7 @@
 
 static int acpi_pci_link_add(struct acpi_device *device,
 			     const struct acpi_device_id *not_used);
-static void acpi_pci_link_remove(struct acpi_device *device);
+static int acpi_pci_link_remove(struct acpi_device *device);
 
 static const struct acpi_device_id link_device_ids[] = {
 	{"PNP0C0F", 0},
@@ -772,7 +772,7 @@ static void irqrouter_resume(void)
 	}
 }
 
-static void acpi_pci_link_remove(struct acpi_device *device)
+static int acpi_pci_link_remove(struct acpi_device *device)
 {
 	struct acpi_pci_link *link;
 
@@ -783,6 +783,7 @@ static void acpi_pci_link_remove(struct acpi_device *device)
 	mutex_unlock(&acpi_link_lock);
 
 	kfree(link);
+	return 0;
 }
 
 /*
diff --git a/drivers/acpi/pci_root.c b/drivers/acpi/pci_root.c
index d7deedf3548e..27cb55882617 100644
--- a/drivers/acpi/pci_root.c
+++ b/drivers/acpi/pci_root.c
@@ -30,7 +30,7 @@
 #define ACPI_PCI_ROOT_DEVICE_NAME	"PCI Root Bridge"
 static int acpi_pci_root_add(struct acpi_device *device,
 			     const struct acpi_device_id *not_used);
-static void acpi_pci_root_remove(struct acpi_device *device);
+static int acpi_pci_root_remove(struct acpi_device *device);
 
 static int acpi_pci_root_scan_dependent(struct acpi_device *adev)
 {
@@ -641,7 +641,7 @@ static int acpi_pci_root_add(struct acpi_device *device,
 	return result;
 }
 
-static void acpi_pci_root_remove(struct acpi_device *device)
+static int acpi_pci_root_remove(struct acpi_device *device)
 {
 	struct acpi_pci_root *root = acpi_driver_data(device);
 
@@ -661,6 +661,7 @@ static void acpi_pci_root_remove(struct acpi_device *device)
 	pci_unlock_rescan_remove();
 
 	kfree(root);
+	return 0;
 }
 
 /*
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 5b54c80b9d32..6d795d6db4ce 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -250,19 +250,22 @@ static int acpi_scan_hot_remove(struct acpi_device *device)
 	acpi_handle handle = device->handle;
 	unsigned long long sta;
 	acpi_status status;
+	int error;
 
 	if (device->handler && device->handler->hotplug.demand_offline) {
 		if (!acpi_scan_is_offline(device, true))
 			return -EBUSY;
 	} else {
-		int error = acpi_scan_try_to_offline(device);
+		error = acpi_scan_try_to_offline(device);
 		if (error)
 			return error;
 	}
 
 	acpi_handle_debug(handle, "Ejecting\n");
 
-	acpi_bus_trim(device);
+	error = acpi_bus_trim(device);
+	if (error)
+		return error;
 
 	acpi_evaluate_lck(handle, 0);
 	/*
@@ -296,8 +299,7 @@ static int acpi_scan_device_not_present(struct acpi_device *adev)
 		dev_warn(&adev->dev, "Still not present\n");
 		return -EALREADY;
 	}
-	acpi_bus_trim(adev);
-	return 0;
+	return acpi_bus_trim(adev);
 }
 
 static int acpi_scan_device_check(struct acpi_device *adev)
@@ -2390,18 +2392,28 @@ EXPORT_SYMBOL(acpi_bus_scan);
  *
  * Must be called under acpi_scan_lock.
  */
-void acpi_bus_trim(struct acpi_device *adev)
+int acpi_bus_trim(struct acpi_device *adev)
 {
 	struct acpi_scan_handler *handler = adev->handler;
 	struct acpi_device *child;
+	int result;
 
-	list_for_each_entry_reverse(child, &adev->children, node)
-		acpi_bus_trim(child);
+	list_for_each_entry_reverse(child, &adev->children, node) {
+		result = acpi_bus_trim(child);
+		if (result) {
+			list_for_each_entry_continue(child, &adev->children, node)
+				acpi_bus_scan(child);
+			return result;
+		}
+	}
 
 	adev->flags.match_driver = false;
 	if (handler) {
-		if (handler->detach)
-			handler->detach(adev);
+		if (handler->detach) {
+			result = handler->detach(adev);
+			if (result)
+				return result;
+		}
 
 		adev->handler = NULL;
 	} else {
@@ -2414,6 +2426,7 @@ void acpi_bus_trim(struct acpi_device *adev)
 	acpi_device_set_power(adev, ACPI_STATE_D3_COLD);
 	adev->flags.initialized = false;
 	acpi_device_clear_enumerated(adev);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index 13d93371790e..e900418e6168 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -125,7 +125,7 @@ struct acpi_scan_handler {
 	struct list_head list_node;
 	bool (*match)(const char *idstr, const struct acpi_device_id **matchid);
 	int (*attach)(struct acpi_device *dev, const struct acpi_device_id *id);
-	void (*detach)(struct acpi_device *dev);
+	int (*detach)(struct acpi_device *dev);
 	void (*bind)(struct device *phys_dev);
 	void (*unbind)(struct device *phys_dev);
 	struct acpi_hotplug_profile hotplug;
@@ -535,7 +535,7 @@ int acpi_scan_add_handler(struct acpi_scan_handler *handler);
 int acpi_bus_register_driver(struct acpi_driver *driver);
 void acpi_bus_unregister_driver(struct acpi_driver *driver);
 int acpi_bus_scan(acpi_handle handle);
-void acpi_bus_trim(struct acpi_device *start);
+int acpi_bus_trim(struct acpi_device *start);
 acpi_status acpi_bus_get_ejd(acpi_handle handle, acpi_handle * ejd);
 int acpi_match_device_ids(struct acpi_device *device,
 			  const struct acpi_device_id *ids);
-- 
2.31.1

