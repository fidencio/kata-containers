From aa0ea7146299eae4aa5326c2da9eabcd0da71319 Mon Sep 17 00:00:00 2001
From: Yuan Yao <yuan.yao@intel.com>
Date: Thu, 1 Jul 2021 16:22:34 +0800
Subject: [PATCH 0472/1418] KVM: TDX: Handle #DB and #BP exception for TD guest

This patch add handler for #DB and #BP for TD guest, to
support hardware/software beakpoint for QEMU's gdbstub.

Signed-off-by: Yuan Yao <yuan.yao@intel.com>
---
 arch/x86/kvm/vmx/tdx.c | 93 ++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 89 insertions(+), 4 deletions(-)

diff --git a/arch/x86/kvm/vmx/tdx.c b/arch/x86/kvm/vmx/tdx.c
index 74efdeb9a2f1..f17df4b6f6fe 100644
--- a/arch/x86/kvm/vmx/tdx.c
+++ b/arch/x86/kvm/vmx/tdx.c
@@ -146,6 +146,9 @@ BUILD_TDVMCALL_ACCESSORS(p2, r13);
 BUILD_TDVMCALL_ACCESSORS(p3, r14);
 BUILD_TDVMCALL_ACCESSORS(p4, r15);
 
+static void tdx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask);
+static int tdx_skip_emulated_instruction(struct kvm_vcpu *vcpu);
+
 static __always_inline unsigned long tdvmcall_exit_type(struct kvm_vcpu *vcpu)
 {
 	return kvm_r10_read(vcpu);
@@ -781,10 +784,18 @@ static fastpath_t tdx_vcpu_run(struct kvm_vcpu *vcpu)
 	/*
 	 * limited to debug td only due to now only debug
 	 * td guest need this feature for instructioin
-	 * emulation/skipping.
+	 * emulation/skipping and TD-off debugging.
 	 */
-	if (is_debug_td(vcpu))
+	if (is_debug_td(vcpu)) {
 		tdx_flush_gprs_dirty(vcpu, false);
+		/*
+		 * Clear corresponding interruptibility bits for STI
+		 * and MOV SS as legacy guest, refer vmx_vcpu_run()
+		 * for more informaiton
+		 */
+		if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)
+			tdx_set_interrupt_shadow(vcpu, 0);
+	}
 
 	tdx_vcpu_enter_exit(vcpu, tdx);
 
@@ -881,12 +892,45 @@ static void tdx_handle_exit_irqoff(struct kvm_vcpu *vcpu)
 
 static int tdx_handle_exception(struct kvm_vcpu *vcpu)
 {
+	u32 ex_no;
+	unsigned long dr6;
+	struct vcpu_tdx *tdx;
+	struct kvm_run *kvm_run = vcpu->run;
 	u32 intr_info = tdexit_intr_info(vcpu);
+	const u32 guest_debug_enable = KVM_GUESTDBG_USE_HW_BP
+		| KVM_GUESTDBG_SINGLESTEP;
 
 	if (is_nmi(intr_info) || is_machine_check(intr_info))
 		return 1;
 
-	kvm_pr_unimpl("unexpected exception 0x%x\n", intr_info);
+	tdx = to_tdx(vcpu);
+	ex_no = intr_info & INTR_INFO_VECTOR_MASK;
+	switch (ex_no) {
+	case DB_VECTOR:
+		dr6 = tdexit_exit_qual(vcpu);
+		if (!(vcpu->guest_debug & guest_debug_enable)) {
+			if (is_icebp(intr_info))
+				WARN_ON(!tdx_skip_emulated_instruction(vcpu));
+
+			kvm_queue_exception_p(vcpu, DB_VECTOR, dr6);
+			return 1;
+		}
+
+		kvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;
+		kvm_run->debug.arch.dr7 = td_vmcs_read64(tdx, GUEST_DR7);
+		fallthrough;
+	case BP_VECTOR:
+		vcpu->arch.event_exit_inst_len =
+			td_vmcs_read32(tdx, VM_EXIT_INSTRUCTION_LEN);
+		kvm_run->exit_reason = KVM_EXIT_DEBUG;
+		kvm_run->debug.arch.pc = kvm_get_linear_rip(vcpu);
+		kvm_run->debug.arch.exception = ex_no;
+		return 0;
+	default:
+		kvm_pr_unimpl("unexpected exception 0x%x\n", intr_info);
+		break;
+	}
+
 	return -EFAULT;
 }
 
@@ -2133,7 +2177,40 @@ static int tdx_vcpu_ioctl(struct kvm_vcpu *vcpu, void __user *argp)
 
 static void tdx_update_exception_bitmap(struct kvm_vcpu *vcpu)
 {
-	/* TODO: Figure out exception bitmap for debug TD. */
+	u32 eb;
+	u32 new_eb;
+	struct vcpu_tdx *tdx = to_tdx(vcpu);
+	const u32 guest_debug_sw_bp = KVM_GUESTDBG_ENABLE
+		| KVM_GUESTDBG_USE_SW_BP;
+
+	if (!is_debug_td(vcpu) || !tdx->initialized)
+		return;
+
+	eb = td_vmcs_read32(tdx, EXCEPTION_BITMAP);
+
+	new_eb = eb | 1u << DB_VECTOR;
+	if ((vcpu->guest_debug & guest_debug_sw_bp) ==
+	    guest_debug_sw_bp) {
+		new_eb |= 1u << BP_VECTOR;
+	} else {
+		new_eb &= ~(1u << BP_VECTOR);
+	}
+
+	/*
+	 * Notice for nested support:
+	 * No nested supporting due to SEAM module doesn't
+	 * support it o far, we shuole consult
+	 * vmx_update_exception_bitmap() when nested support
+	 * become ready in future.
+	 */
+
+	if (new_eb != eb) {
+		u32 verify_eb;
+
+		td_vmcs_write32(tdx, EXCEPTION_BITMAP, new_eb);
+		verify_eb = td_vmcs_read32(tdx, EXCEPTION_BITMAP);
+		KVM_BUG_ON(verify_eb != new_eb, vcpu->kvm);
+	}
 }
 
 static void tdx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)
@@ -2221,14 +2298,22 @@ static unsigned long tdx_get_rflags(struct kvm_vcpu *vcpu)
 
 static void tdx_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)
 {
+	struct vcpu_tdx *tdx = to_tdx(vcpu);
+	u64 val;
+
 	if (KVM_BUG_ON(!is_debug_td(vcpu), vcpu->kvm))
 		return;
 
+	if (!tdx->initialized)
+		return;
+
 	/*
 	 * TODO: This is currently disallowed by TDX-SEAM, which breaks single-
 	 * step debug.
 	 */
 	td_vmcs_write64(to_tdx(vcpu), GUEST_RFLAGS, rflags);
+	val = td_vmcs_read64(to_tdx(vcpu), GUEST_RFLAGS);
+	pr_info("Guest RFLAGS updated to 0x%llx\n", val);
 }
 
 static bool tdx_is_emulated_msr(u32 index, bool write)
-- 
2.31.1

