From 4edf81a54d41ec60f532aba740264203b5ab16ae Mon Sep 17 00:00:00 2001
From: Isaku Yamahata <isaku.yamahata@intel.com>
Date: Thu, 23 Sep 2021 10:49:23 -0700
Subject: [PATCH 0343/1418] *** HACK ***: RFC: x86/cpu/tdx: Use NMI to
 configure the offlined CPU packages for TDX

The TDX requires all CPU packages configured.  For example, memory
encryption key configuration.  And use IPI call to configure the CPU
package.

When the CPU package is offline and maskable IPI isn't usable, use
NMI to invoke callback function on that package instead of maskable IPI.

Signed-off-by: Isaku Yamahata <isaku.yamahata@intel.com>
---
 arch/x86/kernel/cpu/tdx/tdx.c | 85 ++++++++++++++++++++++++++++-------
 1 file changed, 68 insertions(+), 17 deletions(-)

diff --git a/arch/x86/kernel/cpu/tdx/tdx.c b/arch/x86/kernel/cpu/tdx/tdx.c
index 96e693eced2b..1d3a86f12383 100644
--- a/arch/x86/kernel/cpu/tdx/tdx.c
+++ b/arch/x86/kernel/cpu/tdx/tdx.c
@@ -17,6 +17,7 @@
 #include <asm/tdx_host.h>
 #include <asm/virtext.h>
 #include <asm/apic.h>
+#include <asm/nmi.h>
 
 #include "tdmr-sysmem.h"
 #include "tdmr-legacy-pmem.h"
@@ -176,6 +177,7 @@ static void __init tdx_get_keyids(u32 *keyids_start, u32 *nr_keyids)
 }
 
 static int *tdx_package_leaders __read_mostly;
+static int *tdx_package_leaders_nmi __read_mostly;
 
 static enum cpuhp_state cpuhp_state __read_mostly = CPUHP_INVALID;
 
@@ -188,8 +190,10 @@ static int tdx_starting_cpu(unsigned int cpu)
 	 * If this package doesn't have a leader CPU for IPI operation, use this
 	 * CPU as package leader.
 	 */
-	if (tdx_package_leaders[pkg] == -1)
+	if (tdx_package_leaders[pkg] == -1) {
 		tdx_package_leaders[pkg] = cpu;
+		tdx_package_leaders_nmi[pkg] = -1;
+	}
 
 	return ret;
 }
@@ -198,7 +202,6 @@ static int tdx_dying_cpu(unsigned int cpu)
 {
 	int pkg = topology_physical_package_id(cpu);
 	int other;
-	int ret = 0;
 
 	if (tdx_package_leaders[pkg] != cpu)
 		return 0;
@@ -207,6 +210,7 @@ static int tdx_dying_cpu(unsigned int cpu)
 	 * If offlining cpu is used as package leader, find other online cpu on
 	 * this package.
 	 */
+	tdx_package_leaders[pkg] = -1;
 	for_each_online_cpu(other) {
 		if (other == cpu)
 			continue;
@@ -217,14 +221,15 @@ static int tdx_dying_cpu(unsigned int cpu)
 		break;
 	}
 	/*
-	 * Some of the TDX module API (tdh.sys.key.config, tdh.mng.key.config,
-	 * tdh.phymem.page.wbinvd) requires to invoke on all the CPU package.
-	 * Keep at least one CPU online.
+	 * Some of the TDX module API (tdh.sys.key.config, tdh.mng.key.config
+	 * and, tdh.phymem.page.wbinvd) require to invoke on all the CPU
+	 * package. If all CPUs in the package are offline, resort to use NMI
+	 * to invoke a handler on the package.
 	 */
-	if (tdx_package_leaders[pkg] == cpu)
-		ret = -EINVAL;
+	if (tdx_package_leaders[pkg] == -1)
+		tdx_package_leaders_nmi[pkg] = cpu;
 
-	return ret;
+	return 0;
 }
 
 static int __init tdx_init_cpuhp(void)
@@ -240,6 +245,42 @@ static int __init tdx_init_cpuhp(void)
 	return ret;
 }
 
+static int (*tdx_nmi_fn)(void *param);
+static void *tdx_nmi_param;
+static int tdx_nmi_ret;
+static bool tdx_nmi_finished;
+
+static int tdx_nmi_handler(unsigned int cmd, struct pt_regs *regs)
+{
+	int cpu = smp_processor_id();
+	int pkg = topology_physical_package_id(cpu);
+
+	if (tdx_package_leaders_nmi[pkg] != cpu)
+		return NMI_DONE;
+
+	rmb();	/* Read the values set by tdx_trigger_nmi_handler(). */
+	tdx_nmi_ret = tdx_nmi_fn(tdx_nmi_param);
+
+	wmb();	/* Publish return value before marking finished. */
+	WRITE_ONCE(tdx_nmi_finished, true);
+	return NMI_HANDLED;
+}
+
+static int tdx_trigger_nmi_handler(int cpu, int (*fn)(void *param), void *param)
+{
+	tdx_nmi_fn = fn;
+	tdx_nmi_param = param;
+	tdx_nmi_finished = false;
+	/* Ensure those variables are set before sending out the NMI. */
+	wmb();
+
+	apic->send_IPI(cpu, NMI_VECTOR);
+	while (!READ_ONCE(tdx_nmi_finished))
+		cpu_relax();
+	rmb();	/* Ensure the return value is the one stored above. */
+	return READ_ONCE(tdx_nmi_ret);
+}
+
 /*
  * Setup one-cpu-per-pkg array to do package-scoped SEAMCALLs. The array is
  * only necessary if there are multiple packages.
@@ -251,10 +292,20 @@ static int __init init_package_leaders(void)
 	nr_pkgs = topology_max_packages();
 	tdx_package_leaders = kcalloc(nr_pkgs, sizeof(*tdx_package_leaders),
 				GFP_KERNEL);
-	if (!tdx_package_leaders)
+	tdx_package_leaders_nmi = kcalloc(
+		nr_pkgs, sizeof(*tdx_package_leaders_nmi), GFP_KERNEL);
+	if (!tdx_package_leaders || !tdx_package_leaders_nmi) {
+		/* kfree is NULL-safe. */
+		kfree(tdx_package_leaders);
+		kfree(tdx_package_leaders_nmi);
+		tdx_package_leaders = NULL;
+		tdx_package_leaders_nmi = NULL;
 		return -ENOMEM;
+	}
 
 	memset(tdx_package_leaders, -1, nr_pkgs * sizeof(*tdx_package_leaders));
+	memset(tdx_package_leaders_nmi, -1,
+	       nr_pkgs * sizeof(*tdx_package_leaders_nmi));
 
 	nr_filled = 0;
 	for_each_online_cpu(cpu) {
@@ -273,7 +324,8 @@ static int __init init_package_leaders(void)
 		return -EIO;
 	}
 
-	return 0;
+	return register_nmi_handler(NMI_LOCAL, tdx_nmi_handler, 0,
+				"tdx_nmi_handler");
 }
 
 static int tdx_seamcall_on_each_pkg_cpuslocked(int (*fn)(void *), void *param)
@@ -286,13 +338,12 @@ static int tdx_seamcall_on_each_pkg_cpuslocked(int (*fn)(void *), void *param)
 	 */
 	ret = 0;
 	for (i = 0; i < topology_max_packages(); i++) {
-		if (WARN_ON_ONCE(tdx_package_leaders[i] < 0)) {
-			/* All packages need to configure. */
-			ret = -EIO;
-			break;
-		}
-
-		ret = smp_call_on_cpu(tdx_package_leaders[i], fn, param, 1);
+		if (tdx_package_leaders[i] < 0)
+			ret = tdx_trigger_nmi_handler(
+				tdx_package_leaders_nmi[i], fn, param);
+		else
+			ret = smp_call_on_cpu(
+				tdx_package_leaders[i], fn, param, 1);
 		if (ret)
 			break;
 	}
-- 
2.31.1

