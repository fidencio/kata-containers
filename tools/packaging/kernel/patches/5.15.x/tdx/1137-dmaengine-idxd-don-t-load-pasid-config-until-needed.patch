From e829eedf959b64232fc48bd9c3d33b5e13660490 Mon Sep 17 00:00:00 2001
From: Dave Jiang <dave.jiang@intel.com>
Date: Fri, 25 Feb 2022 14:22:05 -0700
Subject: [PATCH 1137/1418] dmaengine: idxd: don't load pasid config until
 needed

The driver currently programs the system pasid to the WQ preemptively when
system pasid is enabled. Given that a dwq will reprogram the pasid and
pasid_en bit, the programming is not necessary. Remove system pasid
programming on device config write. Add pasid programming for kernel wq
type on wq driver enable.

Signed-off-by: Dave Jiang <dave.jiang@intel.com>
---
 drivers/dma/idxd/device.c | 22 +++++++++++++++++-----
 include/uapi/linux/idxd.h |  1 +
 2 files changed, 18 insertions(+), 5 deletions(-)

diff --git a/drivers/dma/idxd/device.c b/drivers/dma/idxd/device.c
index fdaef67eb08a..4386003675eb 100644
--- a/drivers/dma/idxd/device.c
+++ b/drivers/dma/idxd/device.c
@@ -914,11 +914,15 @@ static int idxd_wq_config_write(struct idxd_wq *wq)
 	if (wq_dedicated(wq))
 		wq->wqcfg->mode = 1;
 
-	if (device_pasid_enabled(idxd)) {
+	/*
+	 * Enable this for shared WQ. swq does not need to program the pasid field,
+	 * but pasid_en needs to be set. Programming here prevents swq being disabled
+	 * and re-enabled, which is something to avoid.
+	 */
+	if ((is_idxd_wq_kernel(wq) && device_pasid_enabled(idxd)) ||
+	    ((is_idxd_wq_user(wq) || is_idxd_wq_mdev(wq)) &&
+	     device_user_pasid_enabled(idxd)))
 		wq->wqcfg->pasid_en = 1;
-		if (wq->type == IDXD_WQT_KERNEL && wq_dedicated(wq))
-			wq->wqcfg->pasid = idxd->pasid;
-	}
 
 	/*
 	 * Here the priv bit is set depending on the WQ type. priv = 1 if the
@@ -1120,7 +1124,6 @@ static int idxd_wq_load_config(struct idxd_wq *wq)
 
 	if (device_pasid_enabled(idxd) && wq->wqcfg->mode == 1) {
 		wq->wqcfg->pasid_en = 1;
-		wq->wqcfg->pasid = idxd->pasid;
 		wqcfg_offset = WQCFG_OFFSET(idxd, wq->id, WQCFG_PASID_IDX);
 		iowrite32(wq->wqcfg->bits[WQCFG_PASID_IDX], idxd->reg_base + wqcfg_offset);
 	}
@@ -1351,6 +1354,15 @@ int __drv_enable_wq(struct idxd_wq *wq)
 		}
 	}
 
+	if (device_pasid_enabled(idxd) && is_idxd_wq_kernel(wq) && wq_dedicated(wq)) {
+		rc = idxd_wq_set_pasid(wq, idxd->pasid);
+		if (rc < 0) {
+			idxd->cmd_status = IDXD_SCMD_WQ_PASID_ERR;
+			dev_dbg(dev, "wq set PASID failed.\n");
+			goto err;
+		}
+	}
+
 	rc = 0;
 	spin_lock(&idxd->dev_lock);
 	if (test_bit(IDXD_FLAG_CONFIGURABLE, &idxd->flags))
diff --git a/include/uapi/linux/idxd.h b/include/uapi/linux/idxd.h
index 19e4e532918f..cc311a917b9f 100644
--- a/include/uapi/linux/idxd.h
+++ b/include/uapi/linux/idxd.h
@@ -29,6 +29,7 @@ enum idxd_scmd_stat {
 	IDXD_SCMD_WQ_NO_SIZE = 0x800e0000,
 	IDXD_SCMD_WQ_NO_PRIV = 0x800f0000,
 	IDXD_SCMD_WQ_IRQ_ERR = 0x80100000,
+	IDXD_SCMD_WQ_PASID_ERR = 0x80200000,
 };
 
 #define IDXD_SCMD_SOFTERR_MASK	0x80000000
-- 
2.31.1

