From 2c3e85f8d4f29ad999b13ede74576ec136f55608 Mon Sep 17 00:00:00 2001
From: Jithu Joseph <jithu.joseph@intel.com>
Date: Tue, 15 Feb 2022 10:54:24 -0800
Subject: [PATCH 1063/1418] Revert "drivers/saf: Authenticate the scan chunks
 and copy to secured memory"

This reverts commit 596d1692a0606c67a4f25c5df0240521f5c26d39.
---
 drivers/ift/saf.c | 147 +---------------------------------------------
 drivers/ift/saf.h |  25 --------
 2 files changed, 1 insertion(+), 171 deletions(-)

diff --git a/drivers/ift/saf.c b/drivers/ift/saf.c
index 7ad19f106305..81817f26a824 100644
--- a/drivers/ift/saf.c
+++ b/drivers/ift/saf.c
@@ -9,9 +9,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/vmalloc.h>
-#include <linux/topology.h>
 #include <asm/cpu_device_id.h>
 #include <asm/microcode_intel.h>
 
@@ -26,146 +23,6 @@ static const struct x86_cpu_id saf_cpu_ids[] __initconst = {
 	{}
 };
 
-static const char * const scan_hash_status[] = {
-	"Reserved",
-	"Attempt to copy scan hashes when copy already in progress",
-	"Secure Memory not set up correctly",
-	"FuSaInfo.ProgramID does not match or ff-mm-ss does not match",
-	"Reserved",
-	"Integrity check failed",
-	"Scan test is in progress"
-};
-
-static const char * const scan_authentication_status[] = {
-	"No error reported",
-	"Attempt to authenticate a chunk which is already marked as authentic",
-	"Chunk authentication error. The hash of chunk did not match expected value"
-};
-
-/*
- * To copy scan hashes and authenticate test chunks, the initiating cpu must point
- * to the EDX:EAX to the test image in linear address.
- * Run wrmsr(MSR_COPY_SCAN_HASHES) for scan hash copy and run wrmsr(MSR_AUTHENTICATE_AND_COPY_CHUNK)
- * for scan hash copy and test chunk authetication.
- */
-static int copy_hashes_authenticate_chunks(void *arg)
-{
-	u64 linear_addr, base;
-	u32 eax, edx;
-	int i;
-
-	eax = lower_32_bits(saf_params.hash_ptr);
-	edx = upper_32_bits(saf_params.hash_ptr);
-
-	/* run scan hash copy */
-	wrmsr(MSR_COPY_SCAN_HASHES, eax, edx);
-	rdmsr(MSR_SCAN_HASHES_STATUS, eax, edx);
-
-	/* enumerate the scan image information */
-	saf_params.max_cores = GET_BITFIELD(edx, 19, 30) + 1;
-	saf_params.num_chunks = GET_BITFIELD(eax, 16, 23);
-	saf_params.chunk_size = GET_BITFIELD(eax, 0, 15) * 1024;
-	saf_params.hash_valid = GET_BITFIELD(edx, 31, 31);
-
-	if (!(saf_params.hash_valid)) {
-		saf_params.loading_error = true;
-		if (GET_BITFIELD(edx, 0, 7) >= ARRAY_SIZE(scan_hash_status)) {
-			pr_err("saf: invalid error code for hash copy");
-			return -EINVAL;
-		}
-		pr_err("saf: %s", scan_hash_status[GET_BITFIELD(edx, 0, 7)]);
-		return -ENODEV;
-	}
-	pr_info("saf: the total chunk number: %d", saf_params.num_chunks);
-
-	/* base linear address to the scan data */
-	base = saf_params.test_image_ptr;
-
-	/* scan data authentication and copy chunks to secured memory */
-	for (i = 0; i < saf_params.num_chunks; i++) {
-		linear_addr = base + i * saf_params.chunk_size;
-		edx = upper_32_bits(linear_addr);
-		eax = lower_32_bits(linear_addr);
-		eax |= i;
-
-		wrmsr(MSR_AUTHENTICATE_AND_COPY_CHUNK, eax, edx);
-		rdmsr(MSR_CHUNKS_AUTHENTICATION_STATUS, eax, edx);
-
-		saf_params.valid_chunks = GET_BITFIELD(eax, 0, 7);
-
-		if (GET_BITFIELD(edx, 0, 7)) {
-			if (GET_BITFIELD(edx, 0, 7) >= ARRAY_SIZE(scan_authentication_status)) {
-				pr_err("saf: invalid error code for authentication");
-				return -EINVAL;
-			}
-			saf_params.loading_error = true;
-			pr_err("saf: %s", scan_authentication_status[GET_BITFIELD(edx, 0, 7)]);
-			return -ENODEV;
-		}
-	}
-
-	return 0;
-}
-
-/*
- * SAF requires scan chunks authenticated per each socket in the platform.
- * Once the test chunk is authenticated, it is automatically copied to secured memory
- * and proceed the authentication for the next chunk.
- */
-static int scan_chunks_sanity_check(void)
-{
-	int metadata_size, total_size, test_size, curr_pkg, cpu, ret = -ENOMEM;
-	char *aligned_buf, *test_ptr;
-	bool *package_authenticated;
-
-	package_authenticated = kcalloc(topology_max_packages(), sizeof(bool), GFP_KERNEL);
-	if (!package_authenticated)
-		return ret;
-
-	metadata_size = *((unsigned int *)(saf_params.header_ptr + HEADER_OFFSET_METADATA_SIZE));
-	total_size = *((unsigned int *)(saf_params.header_ptr + HEADER_OFFSET_TOTAL_SIZE));
-	test_size = total_size - metadata_size - HEADER_SIZE;
-	test_ptr = saf_params.header_ptr + HEADER_SIZE + metadata_size;
-
-	/* scan test size is limited to 128MB */
-	if (test_size > TEST_SIZE_LIMIT) {
-		pr_err("saf: the test size is %u, the limit is 128MB", test_size);
-		goto out;
-	}
-
-	/* the linear address to scan chunk must be 256B aligned */
-	aligned_buf = vmalloc(test_size);
-	if (!aligned_buf)
-		goto out;
-
-	memcpy(aligned_buf, test_ptr, test_size);
-	saf_params.test_image_ptr = (u64)(u64 *)aligned_buf;
-	saf_params.loaded_version = *((unsigned int *)(saf_params.header_ptr
-						       + HEADER_OFFSET_IMAGE_REVISION));
-
-	/* copy the scan hash and authenticate per package */
-	cpus_read_lock();
-	for_each_online_cpu(cpu) {
-		curr_pkg = topology_physical_package_id(cpu);
-		if (package_authenticated[curr_pkg])
-			continue;
-		package_authenticated[curr_pkg] = 1;
-		ret = smp_call_function_single(cpu, (void *)copy_hashes_authenticate_chunks,
-					       NULL, 1);
-		if (ret || saf_params.loading_error) {
-			ret = saf_params.loading_error ? -ENOMEM : ret;
-			vfree(aligned_buf);
-			goto out;
-		}
-	}
-	cpus_read_unlock();
-	vfree(aligned_buf);
-out:
-	kfree(package_authenticated);
-
-	return ret;
-}
-
 static int scan_sanity_check(void *mc)
 {
 	struct microcode_header_intel *mc_header = mc;
@@ -294,9 +151,7 @@ int load_scan_binary(void)
 	saf_params.header_ptr = (char *)scan_fw->data;
 	saf_params.hash_ptr = (u64)(saf_params.header_ptr + HEADER_SIZE);
 
-	ret = scan_chunks_sanity_check();
-	if (ret)
-		pr_err("saf: authentication failed");
+	ret = 0;
 out:
 	release_firmware(scan_fw);
 
diff --git a/drivers/ift/saf.h b/drivers/ift/saf.h
index 3be25170f956..ab113b41b85d 100644
--- a/drivers/ift/saf.h
+++ b/drivers/ift/saf.h
@@ -7,25 +7,12 @@
 #ifndef _SAF_H_
 #define _SAF_H_
 
-/*
- * Get a bit field at register value <val>, from bit <lo> to bit <hi>
- */
-#define GET_BITFIELD(val, lo, hi) \
-	(((val) & GENMASK_ULL((hi), (lo))) >> (lo))
-
 /* These bits are in the IA32_CORE_CAPABILITIES MSR */
 #define MSR_IA32_CORE_CAPS_INTEGRITY_BIT	2
 #define MSR_IA32_CORE_CAPS_INTEGRITY		BIT(MSR_IA32_CORE_CAPS_INTEGRITY_BIT)
 
-#define MSR_COPY_SCAN_HASHES			0x000002c2
-#define MSR_SCAN_HASHES_STATUS			0x000002c3
-#define MSR_AUTHENTICATE_AND_COPY_CHUNK		0x000002c4
-#define MSR_CHUNKS_AUTHENTICATION_STATUS	0x000002c5
 #define HEADER_OFFSET_IMAGE_REVISION		4
-#define HEADER_OFFSET_METADATA_SIZE		28
-#define HEADER_OFFSET_TOTAL_SIZE		32
 #define HEADER_SIZE				48
-#define TEST_SIZE_LIMIT				BIT(27)
 
 /**
  * struct saf_params - global saf parameter for all cpus.
@@ -33,24 +20,12 @@
  * @loaded_version: stores the currently loaded scan image version.
  * @hash_ptr: the linear address that points to scan hash loaded.
  * @test_image_ptr: the 512B aligned linear address that points to scan test chunk loaded.
- * @num_chunks: the number of chunks in scan binary.
- * @chunk_size: shows the chunk size.
- * @max_cores: the maximum numbers of cores that scan test can run simultaneously.
- * @loading_error: set if error occurred during scan hashes or chunk authentication.
- * @hash_valid: set when scan hash copy completed.
- * @valid_chunks: the number of authenticated chunks.
  */
 struct saf_params {
 	char *header_ptr;
 	int loaded_version;
 	u64 hash_ptr;
 	u64 test_image_ptr;
-	int num_chunks;
-	int chunk_size;
-	int max_cores;
-	bool loading_error;
-	bool hash_valid;
-	int valid_chunks;
 };
 
 #endif
-- 
2.31.1

